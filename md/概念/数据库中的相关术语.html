<!DOCTYPE HTML>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Oracle 相关 - 数据库中的相关术语</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description">
<meta content="刘士" name="author">

<link href="../../../asserts/lsbook/less/website.css" rel="stylesheet">
<link href="../../../asserts/lsbook/katex/katex.min.css" rel="stylesheet">
<link href="../../../asserts/lsbook/lightbox/css/lightbox.min.css" rel="stylesheet">

<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport">
<meta content="yes" name="apple-mobile-web-app-capable">
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<link href="../../../asserts/lsbook/images/apple-touch-icon-precomposed-152.png"
      rel="apple-touch-icon-precomposed" sizes="152x152">
<link href="../../../asserts/lsbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon">
<!--分页-->
<link href="范式.html" rel="next"/>
</head>
<body>
<div class="book match-braces"><div class="book-summary">
    <div id="book-search-input" role="search">
        <input placeholder="输入并搜索" type="text"/>
    </div>
    <nav role="navigation">
        <ul class="summary">
            <li class="header" title="Summary">Summary</li>
<ul class="articles"><li class="chapter" data-level="1.1" data-path="../../index.html"><a href="../../index.html" title="介绍"><b>1.1.</b>介绍</a></li>
<li class="chapter" data-level="1.2" data-path="../index.html"><a href="../index.html" title="Oracle 部署"><b>1.2.</b>Oracle 部署</a></li>
<li class="chapter" data-level="1.3" data-path="../总结/语法总结.html"><a href="../总结/语法总结.html" title="Oracle 语法总结"><b>1.3.</b>Oracle 语法总结</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html" title="Oracle 概念"><b>1.4.</b>Oracle 概念</a>
<ul class="articles"><li class="chapter" data-level="1.4.1" data-path="../系统结构/系统结构概述.html"><a href="../系统结构/系统结构概述.html" title="系统结构概述"><b>1.4.1.</b>系统结构概述</a>
<ul class="articles"><li class="chapter" data-level="1.4.1.1" data-path="../系统结构/存储结构.html"><a href="../系统结构/存储结构.html" title="存储结构"><b>1.4.1.1.</b>存储结构</a></li>
<li class="chapter" data-level="1.4.1.2" data-path="../系统结构/内存结构.html"><a href="../系统结构/内存结构.html" title="内存结构"><b>1.4.1.2.</b>内存结构</a></li>
<li class="chapter" data-level="1.4.1.3" data-path="../系统结构/后台进程.html"><a href="../系统结构/后台进程.html" title="后台进程"><b>1.4.1.3.</b>后台进程</a></li>
<li class="chapter" data-level="1.4.1.4" data-path="../系统结构/数据字典.html"><a href="../系统结构/数据字典.html" title="数据字典"><b>1.4.1.4.</b>数据字典</a></li></ul></li>
<li class="chapter active" data-level="1.4.2" data-path="数据库中的相关术语.html"><a href="数据库中的相关术语.html" title="数据库中的相关术语"><b>1.4.2.</b>数据库中的相关术语</a></li>
<li class="chapter" data-level="1.4.3" data-path="范式.html"><a href="范式.html" title="范式"><b>1.4.3.</b>范式</a></li>
<li class="chapter" data-level="1.4.4" data-path="E-R图.html"><a href="E-R图.html" title="E-R图"><b>1.4.4.</b>E-R图</a></li>
<li class="chapter" data-level="1.4.5" data-path="Oracle数据类型.html"><a href="Oracle数据类型.html" title="Oracle 数据类型"><b>1.4.5.</b>Oracle 数据类型</a></li></ul></li>
<li class="chapter" data-level="1.5" data-path="../exercise/index.html"><a href="../exercise/index.html" title="Oracle 练习汇总"><b>1.5.</b>Oracle 练习汇总</a>
<ul class="articles"><li class="chapter" data-level="1.5.1" data-path="../exercise/0001.html"><a href="../exercise/0001.html" title="Oracle 练习 0001"><b>1.5.1.</b>Oracle 练习 0001</a></li>
<li class="chapter" data-level="1.5.2" data-path="../exercise/0002.html"><a href="../exercise/0002.html" title="Oracle 练习 0002"><b>1.5.2.</b>Oracle 练习 0002</a></li>
<li class="chapter" data-level="1.5.3" data-path="../exercise/0003.html"><a href="../exercise/0003.html" title="Oracle 练习 0003"><b>1.5.3.</b>Oracle 练习 0003</a></li>
<li class="chapter" data-level="1.5.4" data-path="../exercise/0004.html"><a href="../exercise/0004.html" title="Oracle 练习 0004"><b>1.5.4.</b>Oracle 练习 0004</a></li>
<li class="chapter" data-level="1.5.5" data-path="../exercise/0005.html"><a href="../exercise/0005.html" title="Oracle 练习 0005"><b>1.5.5.</b>Oracle 练习 0005</a></li>
<li class="chapter" data-level="1.5.6" data-path="../exercise/0006.html"><a href="../exercise/0006.html" title="Oracle 练习 0006"><b>1.5.6.</b>Oracle 练习 0006</a></li>
<li class="chapter" data-level="1.5.7" data-path="../exercise/0007.html"><a href="../exercise/0007.html" title="Oracle 练习 0007"><b>1.5.7.</b>Oracle 练习 0007</a></li>
<li class="chapter" data-level="1.5.8" data-path="../exercise/0008.html"><a href="../exercise/0008.html" title="Oracle 练习 0008"><b>1.5.8.</b>Oracle 练习 0008</a></li></ul>
<hr />
<ul class="articles"><li class="chapter" data-level="1.5.9" data-path="../exercise/1001.html"><a href="../exercise/1001.html" title="Oracle 练习 1001"><b>1.5.9.</b>Oracle 练习 1001</a></li>
<li class="chapter" data-level="1.5.10" data-path="../exercise/1002.html"><a href="../exercise/1002.html" title="Oracle 练习 1002"><b>1.5.10.</b>Oracle 练习 1002</a></li>
<li class="chapter" data-level="1.5.11" data-path="../exercise/1003.html"><a href="../exercise/1003.html" title="Oracle 练习 1003"><b>1.5.11.</b>Oracle 练习 1003</a></li>
<li class="chapter" data-level="1.5.12" data-path="../exercise/1004.html"><a href="../exercise/1004.html" title="Oracle 练习 1004"><b>1.5.12.</b>Oracle 练习 1004</a></li>
<li class="chapter" data-level="1.5.13" data-path="../exercise/1005.html"><a href="../exercise/1005.html" title="Oracle 练习 1005"><b>1.5.13.</b>Oracle 练习 1005</a></li>
<li class="chapter" data-level="1.5.14" data-path="../exercise/1006.html"><a href="../exercise/1006.html" title="Oracle 练习 1006"><b>1.5.14.</b>Oracle 练习 1006</a></li>
<li class="chapter" data-level="1.5.15" data-path="../exercise/1007.html"><a href="../exercise/1007.html" title="Oracle 练习 1007"><b>1.5.15.</b>Oracle 练习 1007</a></li>
<li class="chapter" data-level="1.5.16" data-path="../exercise/1008.html"><a href="../exercise/1008.html" title="Oracle 练习 1008"><b>1.5.16.</b>Oracle 练习 1008</a></li>
<li class="chapter" data-level="1.5.17" data-path="../exercise/1009.html"><a href="../exercise/1009.html" title="Oracle 练习 1009"><b>1.5.17.</b>Oracle 练习 1009</a></li>
<li class="chapter" data-level="1.5.18" data-path="../exercise/1010.html"><a href="../exercise/1010.html" title="Oracle 练习 1010"><b>1.5.18.</b>Oracle 练习 1010</a></li>
<li class="chapter" data-level="1.5.19" data-path="../exercise/1011.html"><a href="../exercise/1011.html" title="Oracle 练习 1011"><b>1.5.19.</b>Oracle 练习 1011</a></li>
<li class="chapter" data-level="1.5.20" data-path="../exercise/1012.html"><a href="../exercise/1012.html" title="Oracle 练习 1012"><b>1.5.20.</b>Oracle 练习 1012</a></li>
<li class="chapter" data-level="1.5.21" data-path="../exercise/1013.html"><a href="../exercise/1013.html" title="Oracle 练习 1013"><b>1.5.21.</b>Oracle 练习 1013</a></li>
<li class="chapter" data-level="1.5.22" data-path="../exercise/1014.html"><a href="../exercise/1014.html" title="Oracle 练习 1014"><b>1.5.22.</b>Oracle 练习 1014</a></li>
<li class="chapter" data-level="1.5.23" data-path="../exercise/1015.html"><a href="../exercise/1015.html" title="Oracle 练习 1015"><b>1.5.23.</b>Oracle 练习 1015</a></li>
<li class="chapter" data-level="1.5.24" data-path="../exercise/1016.html"><a href="../exercise/1016.html" title="Oracle 练习 1016"><b>1.5.24.</b>Oracle 练习 1016</a></li>
<li class="chapter" data-level="1.5.25" data-path="../exercise/1017.html"><a href="../exercise/1017.html" title="Oracle 练习 1017"><b>1.5.25.</b>Oracle 练习 1017</a></li>
<li class="chapter" data-level="1.5.26" data-path="../exercise/1018.html"><a href="../exercise/1018.html" title="Oracle 练习 1018"><b>1.5.26.</b>Oracle 练习 1018</a></li>
<li class="chapter" data-level="1.5.27" data-path="../exercise/1019.html"><a href="../exercise/1019.html" title="Oracle 练习 1019"><b>1.5.27.</b>Oracle 练习 1019</a></li>
<li class="chapter" data-level="1.5.28" data-path="../exercise/1020.html"><a href="../exercise/1020.html" title="Oracle 练习 1020"><b>1.5.28.</b>Oracle 练习 1020</a></li>
<li class="chapter" data-level="1.5.29" data-path="../exercise/1021.html"><a href="../exercise/1021.html" title="Oracle 练习 1021"><b>1.5.29.</b>Oracle 练习 1021</a></li>
<li class="chapter" data-level="1.5.30" data-path="../exercise/1022.html"><a href="../exercise/1022.html" title="Oracle 练习 1022"><b>1.5.30.</b>Oracle 练习 1022</a></li>
<li class="chapter" data-level="1.5.31" data-path="../exercise/1023.html"><a href="../exercise/1023.html" title="Oracle 练习 1023"><b>1.5.31.</b>Oracle 练习 1023</a></li></ul>
<hr />
<ul class="articles"><li class="chapter" data-level="1.5.32" data-path="../exercise/2001.html"><a href="../exercise/2001.html" title="Oracle 练习 2001"><b>1.5.32.</b>Oracle 练习 2001</a></li>
<li class="chapter" data-level="1.5.33" data-path="../exercise/2002.html"><a href="../exercise/2002.html" title="Oracle 练习 2002"><b>1.5.33.</b>Oracle 练习 2002</a></li>
<li class="chapter" data-level="1.5.34" data-path="../exercise/2003.html"><a href="../exercise/2003.html" title="Oracle 练习 2003"><b>1.5.34.</b>Oracle 练习 2003</a></li>
<li class="chapter" data-level="1.5.35" data-path="../exercise/2004.html"><a href="../exercise/2004.html" title="Oracle 练习 2004"><b>1.5.35.</b>Oracle 练习 2004</a></li>
<li class="chapter" data-level="1.5.36" data-path="../exercise/2005.html"><a href="../exercise/2005.html" title="Oracle 练习 2005"><b>1.5.36.</b>Oracle 练习 2005</a></li>
<li class="chapter" data-level="1.5.37" data-path="../exercise/2006.html"><a href="../exercise/2006.html" title="Oracle 练习 2006"><b>1.5.37.</b>Oracle 练习 2006</a></li>
<li class="chapter" data-level="1.5.38" data-path="../exercise/2007.html"><a href="../exercise/2007.html" title="Oracle 练习 2007"><b>1.5.38.</b>Oracle 练习 2007</a></li>
<li class="chapter" data-level="1.5.39" data-path="../exercise/2008.html"><a href="../exercise/2008.html" title="Oracle 练习 2008"><b>1.5.39.</b>Oracle 练习 2008</a></li>
<li class="chapter" data-level="1.5.40" data-path="../exercise/2009.html"><a href="../exercise/2009.html" title="Oracle 练习 2009"><b>1.5.40.</b>Oracle 练习 2009</a></li>
<li class="chapter" data-level="1.5.41" data-path="../exercise/2010.html"><a href="../exercise/2010.html" title="Oracle 练习 2010"><b>1.5.41.</b>Oracle 练习 2010</a></li>
<li class="chapter" data-level="1.5.42" data-path="../exercise/2011.html"><a href="../exercise/2011.html" title="Oracle 练习 2011"><b>1.5.42.</b>Oracle 练习 2011</a></li>
<li class="chapter" data-level="1.5.43" data-path="../exercise/2012.html"><a href="../exercise/2012.html" title="Oracle 练习 2012"><b>1.5.43.</b>Oracle 练习 2012</a></li>
<li class="chapter" data-level="1.5.44" data-path="../exercise/2013.html"><a href="../exercise/2013.html" title="Oracle 练习 2013"><b>1.5.44.</b>Oracle 练习 2013</a></li>
<li class="chapter" data-level="1.5.45" data-path="../exercise/2014.html"><a href="../exercise/2014.html" title="Oracle 练习 2014"><b>1.5.45.</b>Oracle 练习 2014</a></li>
<li class="chapter" data-level="1.5.46" data-path="../exercise/2015.html"><a href="../exercise/2015.html" title="Oracle 练习 2015"><b>1.5.46.</b>Oracle 练习 2015</a></li>
<li class="chapter" data-level="1.5.47" data-path="../exercise/2016.html"><a href="../exercise/2016.html" title="Oracle 练习 2016"><b>1.5.47.</b>Oracle 练习 2016</a></li>
<li class="chapter" data-level="1.5.48" data-path="../exercise/2017.html"><a href="../exercise/2017.html" title="Oracle 练习 2017"><b>1.5.48.</b>Oracle 练习 2017</a></li>
<li class="chapter" data-level="1.5.49" data-path="../exercise/2018.html"><a href="../exercise/2018.html" title="Oracle 练习 2018"><b>1.5.49.</b>Oracle 练习 2018</a></li></ul>
<hr />
<ul class="articles"><li class="chapter" data-level="1.5.50" data-path="../exercise/3001.html"><a href="../exercise/3001.html" title="Oracle 练习 3001"><b>1.5.50.</b>Oracle 练习 3001</a></li>
<li class="chapter" data-level="1.5.51" data-path="../exercise/3002.html"><a href="../exercise/3002.html" title="Oracle 练习 3002"><b>1.5.51.</b>Oracle 练习 3002</a></li>
<li class="chapter" data-level="1.5.52" data-path="../exercise/3003.html"><a href="../exercise/3003.html" title="Oracle 练习 3003"><b>1.5.52.</b>Oracle 练习 3003</a></li>
<li class="chapter" data-level="1.5.53" data-path="../exercise/3004.html"><a href="../exercise/3004.html" title="Oracle 练习 3004"><b>1.5.53.</b>Oracle 练习 3004</a></li></ul>
<hr />
<ul class="articles"><li class="chapter" data-level="1.5.54" data-path="../exercise/选择题.html"><a href="../exercise/选择题.html" title="Oracle 选择题"><b>1.5.54.</b>Oracle 选择题</a></li></ul></li></ul>
            <li class="divider"></li>
            <li>
                <a class="lsbook-link" href="https://github.com/liushilive/lsbook" target="blank">
                    本书使用 LsBook 发布
                </a>
            </li>
        </ul>
    </nav>
</div>

<div class="book-body">
    <div class="body-inner">
    <div class="book-header" role="navigation">
        <!-- Title -->
        <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i>
            <a href="../..">数据库中的相关术语</a>
        </h1>
    </div>

    <div class="page-wrapper" role="main" tabindex="-1">
        <div class="page-inner">
            <div class="search-plus" id="book-search-results">
                <div class="search-noresults">
                    <section class="normal markdown-section">
                        <div id='anchor-navigation-ex-navbar'><i class='fa fa-anchor'></i><ul><li><span class='title-icon fa fa-hand-o-right'></span><a aria-label class='on-toolbar-action' href='' onclick="$('.fa.fa-align-justify').parent()[0].click();">目录</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_1'><b></b>数据库中的相关术语</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_2'><b>1. </b>数据库</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_3'><b>2. </b>表</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_4'><b>3. </b>列和数据类型</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_5'><b>4. </b>行</a></li></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_6'><b></b>约束</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_7'><b>1. </b>什么是约束</a></li></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_8'><b></b>事务</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_9'><b>1. </b>什么是事务</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_10'><b>1.1. </b>事务的 ACID 特性</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_11'><b>1.2. </b>控制事务</a></li></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_12'><b>2. </b>什么是锁</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_13'><b>2.1. </b>认识锁</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_14'><b>2.2. </b>锁的分类</a></li></ul></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_15'><b></b>视图</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_16'><b>1. </b>什么是视图</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_17'><b>2. </b>视图的作用</a></li></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_18'><b></b>索引</a></li><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_19'><b></b>存储过程</a></li><ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_20'><b>1. </b>为什么要使用存储过程</a></li></ul><li><span class='title-icon fa fa-hand-o-right'></span><a href='#anchor_21'><b></b>触发器</a></li></ul></div><a href='#anchor_1' id='anchorNavigationExGoTop'><i class='fa fa-arrow-up'></i></a>
                        <h1 id="anchor_1">
    <a class="anchor-navigation-ex-anchor" href="#anchor_1" name="anchor_1">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>数据库中的相关术语
</h1>
<p>在 Oracle 数据库中每个数据库里面都包含很多对象，主要包括表、视图、存储过程、触发器以及约束。在这儿只简单介绍一下每一个术语的含义，在后面会详细地讲解这些术语的使用。</p>
<h2 id="anchor_2">
    <a class="anchor-navigation-ex-anchor" href="#anchor_2" name="anchor_2">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1. 数据库
</h2>
<p><strong>数据库</strong>这个术语的用法很多，但就从 SQL 的角度来看，数据库是一个以某种有组织的方式存储的数据集合。</p>
<p>最简单的办法是将数据库想象为一个文件柜。这个文件柜是一个存放数据的物理位置，不管数据是什么，也不管数据是如何组织的。</p>
<ul>
<li>
<p>数据库（database）</p>
<p>保存有组织的数据的容器（通常是一个文件或一组文件）。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：误用导致混淆</strong></p>
<p>我们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。</p>
<p>确切地说，数据库软件应称为<strong>数据库管理系统</strong>（即 DBMS）。数据库是通过 DBMS 创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。</p>
</blockquote>
<h2 id="anchor_3">
    <a class="anchor-navigation-ex-anchor" href="#anchor_3" name="anchor_3">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>2. 表
</h2>
<p>你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。</p>
<p>在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。</p>
<ul>
<li>
<p>表（table）</p>
<p>某种特定类型数据的结构化清单。</p>
</li>
</ul>
<p>这里的关键一点在于，存储在表中的数据是同一种类型的数据或清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中，否则以后的检索和访问会很困难。应该创建两个表，每个清单一个表。</p>
<p>数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数据库中没有其他表具有相同的名字。</p>
<blockquote>
<p><strong>说明：表名</strong></p>
<p>使表名成为唯一的，实际上是数据库名和表名等的组合。有的数据库还使用数据库所属用户的名字作为唯一名的一部分。也就是说，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中完全可以使用相同的表名。</p>
</blockquote>
<p>表具有一些特性，这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的<strong>模式</strong>（schema），模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）。</p>
<ul>
<li>
<p>模式</p>
<p>关于数据库和表的布局及特性的信息。</p>
</li>
</ul>
<h2 id="anchor_4">
    <a class="anchor-navigation-ex-anchor" href="#anchor_4" name="anchor_4">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>3. 列和数据类型
</h2>
<p>表由列组成。列存储表中某部分的信息。</p>
<ul>
<li>
<p>列（column）</p>
<p>表中的一个字段。所有表都是由一个或多个列组成的。</p>
</li>
</ul>
<p>理解列的最好办法是将数据库表想象为一个网格，就像个电子表格那样。网格中每一列存储着某种特定的信息。例如，在顾客表中，一列存储顾客编号，另一列存储顾客姓名，而地址、城市、县以及邮政编码全都存储在各自的列中。</p>
<blockquote>
<p><strong>提示：分解数据</strong></p>
<p>正确地将数据分解为多个列极为重要。例如，城市、县、邮政编码应该总是彼此独立的列。通过分解这些数据，才有可能利用特定的列对数据进行分类和过滤（如找出特定县或特定城市的所有顾客）。如果城市和县组合在一个列中，则按县进行分类或过滤就会很困难。</p>
<p>你可以根据自己的具体需求来决定把数据分解到何种程度。例如，一般可以把门牌号和街道名一起存储在地址里。这没有问题，除非你哪天想用街道名来排序，这时，最好将门牌号和街道名分开。</p>
</blockquote>
<p>数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可以存储哪些数据种类。例如，如果列中存储的是数字（或许是订单中的物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。</p>
<ul>
<li>
<p>数据类型</p>
<p>所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允许）该列中存储的数据。</p>
</li>
</ul>
<p>数据类型限定了可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须特别关注所用的数据类型。</p>
<blockquote>
<p><strong>注意：数据类型兼容</strong></p>
<p>数据类型及其名称是 SQL 不兼容的一个主要原因。虽然大多数基本数据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是，偶然会有相同的数据类型在不同的 DBMS 中具有不同的名称。对此用户毫无办法，重要的是在创建表结构时要记住这些差异。</p>
</blockquote>
<h2 id="anchor_5">
    <a class="anchor-navigation-ex-anchor" href="#anchor_5" name="anchor_5">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>4. 行
</h2>
<p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。</p>
<p>例如，顾客表可以每行存储一个顾客。表中的行编号为记录的编号。</p>
<ul>
<li>
<p>行（row）</p>
<p>表中的一个记录。</p>
</li>
</ul>
<blockquote>
<p>说明：是记录还是行？</p>
<p>你可能听到用户在提到行时称其为数据库记录（record）。这两个术语多半是可以交替使用的，但从技术上说，行才是正确的术语。</p>
</blockquote>
<hr />
<h1 id="anchor_6">
    <a class="anchor-navigation-ex-anchor" href="#anchor_6" name="anchor_6">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>约束
</h1>
<p>约束是数据库中保证数据库里表中数据完整性的手段。录入数据库中的数据要求都有实际的意义，而约束的作用就是保证数据在实际业务中是有意义的，也就是减少出现脏数据的机会。</p>
<h2 id="anchor_7">
    <a class="anchor-navigation-ex-anchor" href="#anchor_7" name="anchor_7">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1. 什么是约束
</h2>
<p>使用数据库约束就是保证数据库完整性的方法。数据库设计的完整性实际上就是为了保证数据的正确性，那么为了保证数据正确，在数据库中涉及的完整性主要有三个，即<code class="language-vim">实体完整性</code>、<code class="language-vim">区域完整性</code>、<code class="language-vim">参考完整性</code>。</p>
<ul>
<li>
<p>实体完整性</p>
<p>实体完整性针对表中的行数据，要求表中的主键字段都不能为空或者重复的值。</p>
<p>例如，每个人的身份证号码都是唯一的，在学校里每个学生的学号是唯一的，银行卡的卡号也是唯一的，等等。</p>
</li>
<li>
<p>区域完整性</p>
<p>区域完整性针对表中的列数据，是保证输入到数据库中的数据是在有效范围内的，可以通过数据类型或使用检查约束来设置。</p>
<p>比如，输入身份证号码要有 15 位或 18 位，输入年龄只能是数字，输入姓名不能有字母，年龄范围在 1～120 之间等。</p>
</li>
<li>
<p>参照完整性</p>
<p>参照完整性，可以保证数据库中相关联的表里数据的正确性，使用外键约束就可以保证参照完整性。确保数据表的参照完整性，就可以避免错误地删除或增加数据。</p>
<p>比如，学生选了课程，如果因为某种原因，学校取消了该课程，那么可能导致学生该时段没有课程可上，但是加上外键约束后，学校如果想取消该课程，首先得通知学生不选该课程，然后才能删除。所以使用参照完整性设计数据表就会避免产生脏数据。</p>
</li>
</ul>
<blockquote>
<p>注意：不同 DBMS 的约束有几种不同类型的约束，每个 DBMS 都提供自己的支持。因此，这里给出的例子在不同的 DBMS 上可能有不同的反应。在进行试验之前，请参阅具体的 DBMS 文档。</p>
</blockquote>
<hr />
<p>约束是在数据库中保证数据库里表中数据完整性的手段。在 Oracle 中使用的约束有主键约束、外键约束、唯一约束、检查约束、非空约束、默认约束 6 个，其中主键约束和唯一约束都被认为是唯一约束，而外键约束被认为是参照约束。</p>
<ul>
<li>
<p>主键（Primary Key）约束</p>
<p>主键约束在每个数据表中只能有一个，但是一个主键约束可以由多个列组成，通常把由多个列组成的主键又叫做复合主键或组合主键。主键约束可以保证主键列的数据没有重复值且值不为空，也可以说它是保证记录唯一且不为空的一种方式。</p>
<p>表中任意列只要满足以下条件，都可以用于主键：</p>
<ul>
<li>任意两行的主键值都不相同。</li>
<li>每行都具有一个主键值（即列中不允许 NULL 值）。</li>
<li>包含主键值的列从不修改或更新。（大多数 DBMS 不允许这么做，但如果你使用的 DBMS 允许这样做，好吧，千万别！）</li>
<li>主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</li>
</ul>
</li>
<li>
<p>外键（Foreign Key）约束</p>
<p>外键约束之所以被称为是参照约束，是因为它主要用来把一个表中的数据和另一个表中的数据进行关联，表和表之间的关联是为了保证数据库中数据的完整性。使用外键保证数据的完整性，也叫参照完整性。</p>
<p>下面创建 商品信息表，结构如表所示。</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">中文释义</th>
<th align="left">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">ProductId</td>
<td align="left">商品编号</td>
<td align="left">number(20)</td>
</tr>
<tr>
<td align="left">ProductName</td>
<td align="left">商品名称</td>
<td align="left">varchar2(20)</td>
</tr>
<tr>
<td align="left">ProductPrice</td>
<td align="left">商品价格</td>
<td align="left">number(8, 2)</td>
</tr>
<tr>
<td align="left">Quantity</td>
<td align="left">商品数量</td>
<td align="left">number(10)</td>
</tr>
</tbody>
</table>
<p>创建订单信息表，结构如表所示。</p>
<table>
<thead>
<tr>
<th align="left">字段名</th>
<th align="left">中文释义</th>
<th align="left">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">OrderId</td>
<td align="left">订单编号</td>
<td align="left">number(20)</td>
</tr>
<tr>
<td align="left">CustomId</td>
<td align="left">顾客编号</td>
<td align="left">number(20)</td>
</tr>
<tr>
<td align="left">ProductId</td>
<td align="left">商品编号</td>
<td align="left">number(20)</td>
</tr>
<tr>
<td align="left">OrderQuantity</td>
<td align="left">订货数量</td>
<td align="left">number(8)</td>
</tr>
</tbody>
</table>
<p>在实际的操作当中，当客户下订单时会选择商品，而商品必须保证已经存在，所以在商品信息表中商品编号是主键，而在订单信息表中商品编号是外键，当商品信息表中的商品编号与订单信息表中的商品编号设置为外键约束后，在订单信息表中的商品编号就可以使用商品信息表中的商品编号代替。</p>
<p>设置完外键约束后，要求订单信息表中商品编号字段的值必须存在于商品信息表中，同时当在商品信息表中删除一种商品时，如果订单信息表正在使用该种商品，那么商品信息表中的该商品数据就无法被删除，这样就保证了数据库中数据的完整性。</p>
<blockquote>
<p><strong>提示：外键有助防止意外删除</strong></p>
<p>除帮助保证引用完整性外，外键还有另一个重要作用。在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。</p>
<p>有的 DBMS 支持称为<strong>级联删除</strong>（cascading delete）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从 Customers 表中删除某个顾客，则任何关联的订单行也会被自动删除。</p>
</blockquote>
</li>
<li>
<p>唯一（unique）约束</p>
<p>唯一约束和主键约束一样都是设置表中的列不能重复的约束，区别就是一个表中只能有一个主键约束，却可以有多个唯一约束，通常情况下设置唯一约束的目的就是为了使非主键列没有重复值。</p>
<p>唯一约束与主键约束的另一个区别是如果数据表中的某一列中有空值，那么就不能把这个列设置为主键列，但可以设置成唯一约束。</p>
<p>比如，在商品信息表中把商品的编号设置成了主键，但是还要保证商品的名称不重名，就可以对商品名称设置唯一约束。</p>
</li>
<li>
<p>检查（check）约束</p>
<p>检查约束是用来指定表中列的值的取值范围的，该约束更适合完成与业务逻辑相关的限制。</p>
<p>比如，商品信息表中商品数量的列，如果要求商品数量在 10 到 500 之间，就可以使用检查约束进行设置，当输入的值不在有效范围内时，就会出现错误，这样就保证了数据库数据的有效性。</p>
</li>
<li>
<p>非空（not null）约束</p>
<p>非空约束是用来约束表中的列不允许为空的。</p>
<p>例如，在员工信息表中员工身份证号码列，要求员工 必须输入时，可以使用非空约束来保证该列不能为空。</p>
</li>
<li>
<p>默认（default）约束</p>
<p>插入数据没有赋值时，给一个默认值。</p>
</li>
</ul>
<hr />
<h1 id="anchor_8">
    <a class="anchor-navigation-ex-anchor" href="#anchor_8" name="anchor_8">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>事务
</h1>
<p>事务在数据库中主要用于保证数据的一致性，防止出现错误数据。在事务内的语句集会被看成一个单元，语句集中一旦有一条失败，那么所有的都会失败。事务是日常编程当中不可避免要接触的一部分。</p>
<h2 id="anchor_9">
    <a class="anchor-navigation-ex-anchor" href="#anchor_9" name="anchor_9">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1. 什么是事务
</h2>
<p>事务就是组包含 1 条或多条语句的逻辑单元，每个事务都是一个原子单位，在事务中的语句被作为一个整体，要么一起被提交，作用在数据库上，使数据库数据永久的修改；要么一起撤销，对数据库不做任何的修改。</p>
<p>例如银行账户之间的汇款转账操作。该操作在数据库中由以下 3 步完成。</p>
<ol>
<li>源账户减少存储金额，减少 800。</li>
<li>目标账户增加存储金额，增加 800。</li>
<li>在事务日志中记录该事务。</li>
</ol>
<p>整个交易过程，我们看做一个事务，如果操作失败，那么该事务就会回滚，所有该事务中的操作将撤销，目标账户和源账户上的资金都不会出现变化，如果操作成功，那么将是对数据库永久的修改，即使以后服务器断电，硬盘损坏，也不会对该修改结果有影响。</p>
<p>事务在没有提交之前可以回滚，一旦事务提交就不能再撤销修改了。</p>
<h3 id="anchor_10">
    <a class="anchor-navigation-ex-anchor" href="#anchor_10" name="anchor_10">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1.1. 事务的 ACID 特性
</h3>
<p>事务是构成单一逻辑工作单元的操作集合，具有 ACID 特性，即 ATOMIC（原子性）、CONSiSTENT（一致性）、ISOLATED（隔离性）、DURABLE（持久性）。事务的这些特性，适用于任何的数据库，例如 Oracle、MySQL 等，只有具备以上 4 个特点才能称为一个事务。</p>
<ul>
<li>
<p>原子性</p>
<p>事务的原子性是指，事务中程序是数据库的逻辑工作单位，它对数据的修改要么全部执行，要么完全不执行。原子也意味着不可分割，不管有多少程序，只要在同一个事务中，那么它们就是一个整体，如果都执行成功才意味着该事务成功，而只要有一个操作失败，那么同一个事务中的其他操作即使执行成功也没有用，事务会使其全部撤销。</p>
</li>
<li>
<p>一致性</p>
<p>事务的一致性是指，事务执行的前后数据库都必须处于一致状态，它是相对脏读而言的。只有在事务完成后才能被所有使用者看见，保证了数据的完整性。</p>
<p>例如在银行转账时，从 A 账户取款但没有放到 B 账户中的时候是不一致的，数据也是不完整的，其他使用者此时不能看到 A 中修改后的数据，只有存到 B 账户中，交易完成并提交事务，这时才算数据一致，所有用户也会看到修改后的数据。</p>
</li>
<li>
<p>隔离性</p>
<p>分离性是指并发事务之间不能相互干扰，也就是说一个事务操作的数据不会被其他事务看到和操作。</p>
</li>
<li>
<p>持久性</p>
<p>持久性是指一旦事务提交完成，那么这将是对数据永久的修改，即使被修改后的数据遭到破坏，也不会出现回到修改之前的情况。</p>
</li>
</ul>
<blockquote>
<p>开发人员在修改数据的时候一定要提交事务，否则数据将无法保存。但不建议过于频繁地提交事务，主要原因是每次提交事务都需要时间，如果有 80000 行记录，而每条记录都做提交事务操作，那么事务本身将是性能的主要消耗者，所以适当地减少事务提交次数很有必要，例如可以每 100 行提交一次，实际情况可以根据项目要求决定。</p>
</blockquote>
<h3 id="anchor_11">
    <a class="anchor-navigation-ex-anchor" href="#anchor_11" name="anchor_11">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1.2. 控制事务
</h3>
<p>当一个事务被执行并成功完成时，虽然从输出结果来看目标表已经被修改了，但实际上目标表并不是立即被修改。当事务成功完成时，利用事务控制命令最终认可这个事务，可以把事务所做的修改保存到数据库，也可以撤销事务所做的修改。</p>
<p><a data-lightbox="1" href="../../lsbook_import_img/2018-06-27-10-19-21.png"><img src="../../lsbook_import_img/2018-06-27-10-19-21.png" alt="修改操作如何应用到关系型数据库" title="修改操作如何应用到关系型数据库" /></a></p>
<p>事务控制命令只与 <code class="language-vim">DML</code> 命令 <code class="language-vim">insert</code>、<code class="language-vim">update</code> 和 <code class="language-vim">delete</code> 配合使用，比如我们不会在创建表之后使用 <code class="language-vim">commit</code> 语句，因为当表被创建之后，它会自动被提交给数据库。也不能使用 <code class="language-vim">rollback</code> 语句来恢复被撤销的表。</p>
<p>此外，还有其他类似的语句，也是不能被撤销的，例如 <code class="language-vim">truncate</code> 语句。所以，在运行新的命令前，最好先确认一下用户所使用的 <code class="language-vim">DBMS</code> 在事务方面的相关规定。当事务完成之后，事务信息被保存在数据库里的指定区域或临时回退区域。所有的修改都被保存到这个临时回退区域，直到事务控制命令出现。当事务控制命令出现时，所做的修改要么被保存到数据库，要么被放弃，然后临时回退区域被清空。</p>
<p>事务基本控制语句有如下几个：</p>
<ul>
<li>
<p>commit：提交事务</p>
</li>
<li>
<p>savepoint：设置保存点</p>
</li>
<li>
<p>rollback：回滚事务</p>
</li>
<li>
<p>rollback to savepoint：回滚至保存点</p>
</li>
</ul>
<p>代码演示：</p>
<pre class="line-numbers"><code class="lang-sql rainbow-braces">commit;
savepoint a1;
rollback to a1;
rollback;
</code></pre>
<p>在 MySQL 数据库中，在命令行中，事务默认是自动提交的，要显式开启事务需要使用命令 <code class="language-vim">begin</code>，修改后如需提交使用 <code class="language-vim">commit</code>。</p>
<p>在 MySQL 远程连接工具中，与 Oracle 保持一致。</p>
<h2 id="anchor_12">
    <a class="anchor-navigation-ex-anchor" href="#anchor_12" name="anchor_12">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>2. 什么是锁
</h2>
<p>锁定是数据库引擎为了避免数据出现异常，而限制多个用户在同一时间访问相同数据块的一种机制。锁定机制是通过锁（LOCK）来实现的，当对一个数据源加锁后，此数据源就有了一定的访问限制，也就是对此数据源进行了锁定。</p>
<h3 id="anchor_13">
    <a class="anchor-navigation-ex-anchor" href="#anchor_13" name="anchor_13">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>2.1. 认识锁
</h3>
<p>锁出现在数据共享的环境中，它是一种机制，在访问相同资源时，可以防止事务之间的破坏性交互。例如，在多个会话同时操作某表时，优先操作的会话需要对其锁定。</p>
<p>在 DBMS 中，允许一个事务锁定不同类型的资源，包括数据行、表，也有可能是数据库本身，锁的模式根据需要处理的事件不同而有所差异。</p>
<p>在 DBMS 中，通常锁不是由开发者主动使用的，而是由系统自动进行加锁和解锁。在 DBMS 中，锁由数据库引擎中的锁管理器在内部管理。当执行 SQL 语句时，数据库查询处理器会自动决定将要访问哪些资源，并根据访问的类型和事务隔离级别设置来确定保护每一资源所需的锁的类型。然后，查询处理器将向锁管理器请求适当的锁，如果与其他事务所持有的锁不会发生冲突，锁管理器将授予该锁。</p>
<p>例如，当一个会话对表 A 的某行记录进行修改时，另一个会话也来修改该行记录，在没有任何处理的情况下保留的数据会有随机性，而这种数据是没有任何意义的，为脏数据。如果此时使用了行级锁，第一个会话修改记录时封锁该行，那么第二个会话此时只能等待，这样就避免了脏数据的产生。</p>
<h3 id="anchor_14">
    <a class="anchor-navigation-ex-anchor" href="#anchor_14" name="anchor_14">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>2.2. 锁的分类
</h3>
<p>了解两种基本的锁，一种是排他锁（X 锁），另一种是共享锁（S 锁）。</p>
<ul>
<li>
<p>排他锁也可以叫写锁。</p>
<p>这种模式的锁防止资源的共享，用做数据的修改。</p>
<p>假如有事务 T 给数据 A 加上该锁，那么其他的事务将不能对 A 加任何的锁，所以此时只允许 T 对该数据进行读取和修改，直到事务完成将该类型的锁释放为止。</p>
</li>
<li>
<p>共享锁也可以叫读锁。</p>
<p>该模式锁下的数据只能被读取，不能被修改。</p>
<p>如果有事务 T 给数据 A 加上共享锁后，那么其他事务不能对其加排他锁，只能加共享锁。加了该锁的数据可以被并发地读取。</p>
</li>
</ul>
<p>锁是实现并发的主要手段，在数据库中应用频繁，但很多都由数据库自动管理，当事务提交后会自动释放锁。</p>
<hr />
<h1 id="anchor_15">
    <a class="anchor-navigation-ex-anchor" href="#anchor_15" name="anchor_15">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>视图
</h1>
<p>视图在 Oracle 中应用相当普遍，所以也比较重要。视图在数据库中可以理解为一张虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。使用视图可以补充表结构在某些需求方面的不足，可以让开发人员更方便地查询复杂数据，还可以缩短开发周期，节省公司成本。</p>
<h2 id="anchor_16">
    <a class="anchor-navigation-ex-anchor" href="#anchor_16" name="anchor_16">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1. 什么是视图
</h2>
<p>听到视图会比较陌生，实际上视图的创建和操作比较简单。在直观印象中它和表类似，但某些表的功能它不具备。</p>
<p>根据官方的文档可以这样理解视图：它是一个基于一个表或多个表的逻辑表，视图本身不包含任何数据。</p>
<p>通俗来说，可以把视图看成是虚拟的表，只是一个查询语句的结果，它的数据最终是从表中获取的，这些表通常称为 <strong>源表</strong> 或 <strong>基表</strong> 。当基表的数据发生变化时，视图里的数据同样发生变化。通常视图的数据源有三种情况：</p>
<ul>
<li>
<p>单一表的子集。</p>
</li>
<li>
<p>多表操作结果集。</p>
</li>
<li>
<p>视图的子集。</p>
</li>
</ul>
<h2 id="anchor_17">
    <a class="anchor-navigation-ex-anchor" href="#anchor_17" name="anchor_17">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>2. 视图的作用
</h2>
<p>我们会产生疑问，既然视图被称为虚拟的表，那还用它做什么？下面就简单介绍一下视图的作用。</p>
<ul>
<li>
<p>使数据简化</p>
<p>在表中很多数据对业务来说是冗余的，这时开发者会使用比较复杂的 SQL 语句得到自己想要的。实际开发中不能要求每个人都能做到这一点，所以，通常情况下由一个人把该复杂语句做成视图，其他人员直接调用该视图即可。这样对视图使用人员就简化了数据，隐藏了数据的复杂性。</p>
</li>
<li>
<p>使数据更加独立</p>
<p>程序开发时，大多数是程序直接访问数据库的表，当这些表的结构随着业务的变化而不得不重新设计时会影响到程序（通常表一旦设计完成就很难再做修改），所以可以使得程序直接访问视图。这样视图就可以把程序和数据库的表隔离开来，降低开发者的劳动成本。</p>
</li>
<li>
<p>增加安全性</p>
<p>视图可以查询表指定的列来展现给用户，而不必让使用者完全看见表的所有字段。这种情况很多是一个公司提供给其他合作伙伴查询数据的接口，而视图通常也会设成只读属性。</p>
</li>
</ul>
<blockquote>
<p>警告：性能问题</p>
<p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
</blockquote>
<hr />
<h1 id="anchor_18">
    <a class="anchor-navigation-ex-anchor" href="#anchor_18" name="anchor_18">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>索引
</h1>
<p>索引用来排序数据以加快搜索和排序操作的速度。想像一本书后的索引，可以帮助你理解数据库的索引。</p>
<p>假如要找出书中所有的<code class="language-vim">数据类型</code>这个词，简单的办法是从第 1 页开始，浏览每一行。虽然这样做可以完成任务，但显然不是一种好的办法。浏览少数几页文字可能还行，但以这种方式浏览整部书就不可行了。随着要搜索的页数不断增加，找出所需词汇的时间也会增加。</p>
<p>这就是书籍要有索引的原因。索引按字母顺序列出词汇及其在书中的位置。为了搜索<code class="language-vim">数据类型</code>一词，可在索引中找出该词，确定它出现在哪些页中。然后再翻到这些页，找出<code class="language-vim">数据类型</code>一词。</p>
<p>使索引有用的因素是什么？很简单，就是恰当的排序。找出书中词汇的困难不在于必须进行多少搜索，而在于书的内容没有按词汇排序。如果书的内容像字典一样排序，则索引没有必要（因此字典就没有索引）。</p>
<p>数据库索引的作用也一样。主键数据总是排序的，这是 DBMS 的工作。因此，按主键检索特定行总是一种快速有效的操作。</p>
<p>但是，搜索其他列中的值通常效率不高。例如，如果想搜索住在某个县的客户，怎么办？因为表数据并未按县排序，DBMS 必须读出表中所有行（从第一行开始），看其是否匹配。这就像要从没有索引的书中找出词汇一样。</p>
<p>解决方法是使用索引。可以在一个或多个列上定义索引，使 DBMS 保存其内容的一个排过序的列表。在定义了索引后，DBMS 以使用书的索引类似的方法使用它。DBMS 搜索排过序的索引，找出匹配的位置，然后检索这些行。</p>
<p>在开始创建索引前，应该记住以下内容：</p>
<ul>
<li>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS 必须动态地更新索引。</li>
<li>索引数据可能要占用大量的存储空间。</li>
<li>并非所有数据都适合做索引。取值不多的数据（如县）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。</li>
<li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</li>
<li>可以在索引中定义多个列（例如，县加上城市）。这样的索引仅在以县加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</li>
</ul>
<p>没有严格的规则要求什么应该索引，何时索引。大多数 DBMS 提供了可用来确定索引效率的实用程序，应该经常使用这些实用程序。</p>
<blockquote>
<p>提示：检查索引</p>
<p>索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。</p>
</blockquote>
<hr />
<h1 id="anchor_19">
    <a class="anchor-navigation-ex-anchor" href="#anchor_19" name="anchor_19">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>存储过程
</h1>
<p>迄今为止，我们使用的大多数 SQL 语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一些复杂的操作需要多条语句才能完成。</p>
<p>例如以下的情形：</p>
<ul>
<li>为了处理订单，必须核对以保证库存中有相应的物品。</li>
<li>如果物品有库存，需要预定，不再出售给别的人，并且减少物品数据以反映正确的库存量。</li>
<li>库存中没有的物品需要订购，这需要与供应商进行某种交互。</li>
<li>关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的顾客。</li>
</ul>
<p>这显然不是一个完整的例子，它甚至超出了我们所学范例的范围，但足以表达我们的意思了。执行这个处理需要针对许多表的多条 SQL 语句。此外，需要执行的具体 SQL 语句及其次序也不是固定的，它们可能会根据物品是否在库存中而变化。</p>
<p>那么，怎样编写代码呢？可以单独编写每条 SQL 语句，并根据结果有条件地执行其他语句。在每次需要这个处理时（以及每个需要它的应用中），都必须做这些工作。</p>
<p>可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<h2 id="anchor_20">
    <a class="anchor-navigation-ex-anchor" href="#anchor_20" name="anchor_20">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>1. 为什么要使用存储过程
</h2>
<p>我们知道了什么是存储过程，那么为什么要使用它们呢？</p>
<p>理由很多，下面列出一些主要的。</p>
<ul>
<li>通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。</li>
<li>由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。</li>
<li>这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li>
<li>这一点的延伸就是安全性。通过存储过程限制对基础数据的访问，减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li>
<li>因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令的工作较少，提高了性能。</li>
</ul>
<p>存在一些只能用在单个请求中的 SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</p>
<p>换句话说，使用存储过程有三个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将 SQL 代码转换为存储过程前，也必须知道它的一些缺陷。</p>
<ul>
<li>不同 DBMS 中的存储过程语法有所不同。事实上，编写真正的可移植存储过程几乎是不可能的。不过，存储过程的自我调用（名字以及数据如何传递）可以相对保持可移植。因此，如果需要移植到别的 DBMS，至少客户端应用代码不需要变动。</li>
<li>一般来说，编写存储过程比编写基本 SQL 语句复杂，需要更高的技能，更丰富的经验。因此，许多数据库管理员把限制存储过程的创建作为安全措施（主要受上一条缺陷的影响）。</li>
</ul>
<p>尽管有这些缺陷，存储过程还是非常有用的，并且应该使用。事实上，多数 DBMS 都带有用于管理数据库和表的各种存储过程。更多信息请参阅具体的 DBMS 文档。</p>
<blockquote>
<p>说明：不能编写存储过程？你依然可以使用</p>
<p>大多数 DBMS 将编写存储过程所需的安全和访问权限与执行存储过程所需的安全和访问权限区分开来。这是好事情，即使你不能（或不想）编写自己的存储过程，也仍然可以在适当的时候执行别的存储过程。</p>
</blockquote>
<hr />
<h1 id="anchor_21">
    <a class="anchor-navigation-ex-anchor" href="#anchor_21" name="anchor_21">
        <i aria-hidden="true" class="fa fa-link"></i>
    </a>触发器
</h1>
<p>触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的 insert、update 和 delete 操作（或组合）相关联。</p>
<p>与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单个的表相关联。与 Orders 表上的 insert 操作相关联的触发器只在 Orders 表中插入行时执行。类似地，Customers 表上的 insert 和 update 操作的触发器只在表上出现这些操作时执行。</p>
<p>触发器内的代码具有以下数据的访问权：</p>
<ul>
<li><code class="language-vim">insert</code> 操作中的所有新数据；</li>
<li><code class="language-vim">update</code> 操作中的所有新数据和旧数据；</li>
<li><code class="language-vim">delete</code> 操作中删除的数据。</li>
</ul>
<p>根据所使用的 DBMS 的不同，触发器可在特定操作执行之前或之后执行。</p>
<p>下面是触发器的一些常见用途。</p>
<ul>
<li>保证数据一致。例如，在 insert 或 update 操作中将所有州名转换为大写。</li>
<li>基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。</li>
<li>进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。</li>
<li>计算计算列的值或更新时间戳。</li>
</ul>
<p>不同 DBMS 的触发器创建语法差异很大，更详细的信息请参阅相应的文档。</p>

                        <footer class="page-footer">
<span class="copyright">© 2021 刘士. All rights reserved.</span>
<span class="footer-modification">
<span id="busuanzi_container_site_uv" style="display:none">本站访客数 <span id="busuanzi_value_site_uv">
</span> 人次</span></span>
</footer><script>
function busuanzi(){
    if (document.domain != "127.0.0.1") {$.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");}
}
setTimeout('busuanzi()', 2000);
</script><script>

</script>
                    </section>
                </div>
                <div class="search-results">
                    <div class="has-results">
                        <h1 class="search-results-title"><span class='search-results-count'></span> 结果匹配 "<span class='search-query'></span>"</h1>
                        <ul class="search-results-list"></ul>
                    </div>
                    <div class="no-results">
                        <h1 class="search-results-title">没有匹配的结果 "<span class='search-query'></span>"</h1>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<a aria-label="Previous page: 数据字典" class="navigation navigation-prev" href="../系统结构/数据字典.html">
    <i class="fa fa-angle-left"></i>
</a>


<a aria-label="Next page: 范式" class="navigation navigation-next" href="范式.html">
    <i class="fa fa-angle-right"></i>
</a>


</div>
<script>
    var lsbook = lsbook || [];
    lsbook.push(function () {
        lsbook.page.hasChanged({
            "config": {
                "github_url":"https://liushilive.github.io/",
                "language": "zh-cn",
                "previous_page_link": "../系统结构/数据字典.html",
                "next_page_link": "范式.html"
            },
            "basePath": "../..",
            "js": {'prism': ['../../../asserts/lsbook/prismjs/clipboard.min.js', '../../../asserts/lsbook/prismjs/prism.js']}
        });
    });
</script>
</div>

<script src="../../../asserts/lsbook/jquery-3.3.1.min.js"></script>
<script charset="UTF-8" src="../../../asserts/lsbook/jquery_mar/jquery.mark.js"></script>
<script src="../../../asserts/lsbook/lightbox/js/lightbox.min.js"></script>
<script src="../../../asserts/lsbook/lsbook.min.js"></script>

</body>
</html>
