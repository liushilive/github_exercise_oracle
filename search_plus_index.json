{"index.html": {"url": "index.html", "title": "介绍", "keywords": "", "body": "Oracle相关"}, "md/index.html": {"url": "md/index.html", "title": "Oracle 部署", "keywords": "", "body": "Oracle部署局域网内部环境使用非局域网内部环境请参考外网环境部署虚拟机还原到系统安装完毕快照1.部署本地yum源rm-rf/etc/yum.repos.d/*curl-o/etc/yum.repos.d/CentOS-7.repohttp://192.168.2.251/Centos/CentOS7.repoyumcleanallyummakecache2.安装必需的安装包yuminstall-ylibaiobcflexnet-tools3.安装Oraclerpm-ivhhttp://192.168.2.251/Centos/oracle/oracle-xe-11.2.0-1.0.x86_64.rpm4.配置OralceOracleApplicationExpress的有效HTTP端口（默认值为8080）Oracle数据库侦听器的有效端口（默认为1521）SYS和SYSTEM管理员帐户密码：123456确认SYS和SYSTEM管理员帐户的密码：123456数据库在计算机启动时自动启动（下次重新引导）echo-e&quot;\\n\\n123456\\n123456\\ny&quot;|/etc/init.d/oracle-xeconfigure5.环境变量配置cat&gt;&gt;.bash_profile&lt;&lt;EOF./u01/app/oracle/product/11.2.0/xe/bin/oracle_env.shEOF让环境变量生效su-6.允许远程访问Oracle11gXEGUI进入SQL命令窗口sqlplus&quot;sys/123456assysdba&quot;&lt;&lt;EOFEXECDBMS_XDB.SETLISTENERLOCALACCESS(FALSE);EOF7.直接关闭防火墙systemctlstopfirewalldsystemctldisablefirewalld可通下面网址访问确认安装成功http://&lt;server-ip&gt;:8080/apex/f?p=4950:1用户名：system密码：1234568.一键部署rm-rf/etc/yum.repos.d/*curl-o/etc/yum.repos.d/CentOS-7.repohttp://192.168.2.251/Centos/CentOS7.repoyumcleanallyummakecacheyuminstall-ylibaiobcflexnet-toolsrpm-ivhhttp://192.168.2.251/Centos/oracle/oracle-xe-11.2.0-1.0.x86_64.rpmecho-e&quot;\\n\\n123456\\n123456\\ny&quot;|/etc/init.d/oracle-xeconfigurecat&gt;&gt;.bash_profile&lt;&lt;EOF./u01/app/oracle/product/11.2.0/xe/bin/oracle_env.shEOFsu-sqlplus&quot;sys/123456assysdba&quot;&lt;&lt;EOFEXECDBMS_XDB.SETLISTENERLOCALACCESS(FALSE);EOFsystemctlstopfirewalldsystemctldisablefirewalld"}, "md/总结/语法总结.html": {"url": "md/总结/语法总结.html", "title": "Oracle 语法总结", "keywords": "", "body": "Oracle语法总结create\\[\\textcolor{#228B22}{create}\\begin{cases}\\textcolor{#228B22}{user}\\space用户名\\space\\textcolor{#228B22}{identified\\spaceby\\space}密码\\space[\\textcolor{#228B22}{account\\spacelock}|\\textcolor{#228B22}{unlock}];\\\\\\textcolor{#228B22}{table}\\space表名(列名\\space类型\\space[\\textcolor{#228B22}{null}|\\textcolor{#228B22}{not\\spacenull}]\\space[\\textcolor{#228B22}{constraint}]);\\\\[\\textcolor{#228B22}{or\\spacereplace}]\\space[\\textcolor{#228B22}{noforce}|\\textcolor{#228B22}{force}]\\space\\textcolor{#228B22}{view}\\space视图名\\space\\textcolor{#228B22}{as}\\spaceselect查询\\space[\\textcolor{#228B22}{with\\spaceread\\spaceonly}];\\\\[\\textcolor{#228B22}{unique}]\\space\\textcolor{#228B22}{index}\\space索引名\\space\\textcolor{#228B22}{on}\\space表名(列名\\space[,\\space列名…]);\\\\\\end{cases}\\]alter\\[\\textcolor{#228B22}{alter}\\begin{cases}\\textcolor{#228B22}{user}\\space用户名\\space{\\begin{cases}\\textcolor{#228B22}{identified\\spaceby}\\space新密码;\\\\\\textcolor{#228B22}{account\\spacelock}|\\textcolor{#228B22}{unlock};\\end{cases}}\\\\\\textcolor{#228B22}{table}\\space表名\\space{\\begin{cases}\\textcolor{#228B22}{add}\\space{\\begin{cases}列名\\space列类型\\space列约束;\\\\\\textcolor{#228B22}{constraint}\\space约束名\\space{\\begin{cases}\\textcolor{#228B22}{primary\\spacekey}(列);\\\\\\textcolor{#228B22}{foreign\\spacekey}(列)\\space\\textcolor{#228B22}{references}\\space参照表(参照列);\\\\\\textcolor{#228B22}{unique}(列);\\\\\\textcolor{#228B22}{check}(条件);\\\\\\end{cases}}\\end{cases}}\\\\\\textcolor{#228B22}{drop}\\space{\\begin{cases}\\textcolor{#228B22}{column}\\space列名;\\\\\\textcolor{#228B22}{constraint}\\space约束名;\\end{cases}}\\\\\\textcolor{#228B22}{modify}\\space列\\space{\\begin{cases}\\textcolor{#228B22}{not\\spacenull}|\\textcolor{#228B22}{null};\\\\\\textcolor{#228B22}{default}\\space默认值|\\textcolor{#228B22}{null};\\end{cases}}\\end{cases}}\\end{cases}\\]drop\\[\\textcolor{#228B22}{alter}\\begin{cases}\\textcolor{#228B22}{user}\\space用户名\\space[\\textcolor{#228B22}{cascade}];\\\\\\textcolor{#228B22}{table}\\space表名;\\\\\\textcolor{#228B22}{view}\\space视图名;\\\\\\textcolor{#228B22}{index}\\space索引名;\\\\\\end{cases}\\]语法结构：查询select[distinct]*|列|表达式fromAjoinB--内连接on表之间关联的条件rightjoinC--右外连接on表之间关联的条件leftjoinD--左外连接on表之间关联的条件fulljoinE--全连接on表之间关联的条件where结果筛选条件groupby分组列having分组后结果筛选orderby排序列[asc|desc];语法结构：创建用户createuser用户名identifiedby口令[accountlock|unlock];语法结构：修改用户的密码alteruser用户名identifiedby新密码;语法结构：修改用户处于锁定（非锁定）状态alteruser用户名accountlock|unlock;语法结构：删除用户dropuser用户名cascade;语法结构：授予权限grant角色|权限to用户|角色;语法结构：回收权限revoke角色|权限from用户|角色;语法结构：创建表createtable表名(列名1类型[null|notnull][constraint],类名2类型);语法结构：修改表名rename原表名to新表名;语法结构：添加列altertable表名add列名列类型列约束;语法结构：删除列altertable表名dropcolumn列名;语法结构：删除表droptable表名;语法结构：添加约束altertable表名addconstraint约束名约束内容;语法结构：删除约束altertable表名dropconstraint约束名;语法结构：：数据插入insertinto表名(列名1，列名2……)VALUES(值1，值2……)语法结构：：更新数据update表名set列名1=值,列名2=值where条件;语法结构：：删除数据deletefrom表名where条件;语法结构：：删除全部数据！！无法回滚，高危！truncatetable表名;"}, "md/概念.html": {"url": "md/概念.html", "title": "Oracle 概念", "keywords": "", "body": "Oracle概念"}, "md/数据库中的相关术语.html": {"url": "md/数据库中的相关术语.html", "title": "数据库中的相关术语", "keywords": "", "body": "数据库中的相关术语在Oracle数据库中每个数据库里面都包含很多对象，主要包括表、视图、存储过程、触发器以及约束。在这儿只简单介绍一下每一个术语的含义，在后面会详细地讲解这些术语的使用。1.数据库数据库这个术语的用法很多，但就从SQL的角度来看，数据库是一个以某种有组织的方式存储的数据集合。最简单的办法是将数据库想象为一个文件柜。这个文件柜是一个存放数据的物理位置，不管数据是什么，也不管数据是如何组织的。数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。注意：误用导致混淆我们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统（即DBMS）。数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。2.表你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。表（table）某种特定类型数据的结构化清单。这里的关键一点在于，存储在表中的数据是同一种类型的数据或清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中，否则以后的检索和访问会很困难。应该创建两个表，每个清单一个表。数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数据库中没有其他表具有相同的名字。说明：表名使表名成为唯一的，实际上是数据库名和表名等的组合。有的数据库还使用数据库拥有者的名字作为唯一名的一部分。也就是说，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中完全可以使用相同的表名。表具有一些特性，这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的模式（schema），模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）。模式关于数据库和表的布局及特性的信息。3.列和数据类型表由列组成。列存储表中某部分的信息。列（column）表中的一个字段。所有表都是由一个或多个列组成的。理解列的最好办法是将数据库表想象为一个网格，就像个电子表格那样。网格中每一列存储着某种特定的信息。例如，在顾客表中，一列存储顾客编号，另一列存储顾客姓名，而地址、城市、县以及邮政编码全都存储在各自的列中。提示：分解数据正确地将数据分解为多个列极为重要。例如，城市、县、邮政编码应该总是彼此独立的列。通过分解这些数据，才有可能利用特定的列对数据进行分类和过滤（如找出特定县或特定城市的所有顾客）。如果城市和县组合在一个列中，则按县进行分类或过滤就会很困难。你可以根据自己的具体需求来决定把数据分解到何种程度。例如，一般可以把门牌号和街道名一起存储在地址里。这没有问题，除非你哪天想用街道名来排序，这时，最好将门牌号和街道名分开。数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可以存储哪些数据种类。例如，如果列中存储的是数字（或许是订单中的物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。数据类型所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允许）该列中存储的数据。数据类型限定了可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须特别关注所用的数据类型。注意：数据类型兼容数据类型及其名称是SQL不兼容的一个主要原因。虽然大多数基本数据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是，偶然会有相同的数据类型在不同的DBMS中具有不同的名称。对此用户毫无办法，重要的是在创建表结构时要记住这些差异。4.行表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。例如，顾客表可以每行存储一个顾客。表中的行编号为记录的编号。行（row）表中的一个记录。说明：是记录还是行？你可能听到用户在提到行时称其为数据库记录（record）。这两个术语多半是可以交替使用的，但从技术上说，行才是正确的术语。约束SQL已经改进过多个版本，成为非常完善和强大的语言。许多强有力的特性给用户提供了高级的数据处理技术，如约束。关系数据库存储分解为多个表的数据，每个表存储相应的数据。利用键来建立从一个表到另一个表的引用（由此产生了术语引用完整性（referentialintegrity））。正确地进行关系数据库设计，需要一种方法保证只在表中插入合法数据。例如，如果Orders表存储订单信息，OrderItems表存储订单详细内容，应该保证OrderItems中引用的任何订单ID都存在于Orders中。类似地，在Orders表中引用的任意顾客必须存在于Customers表中。虽然可以在插入新行时进行检查（在另一个表上执行SELECT，以保证所有值合法并存在），但最好不要这样做，原因如下：如果在客户端层面上实施数据库完整性规则，则每个客户端都要被迫实施这些规则，一定会有一些客户端不实施这些规则。在执行update和delete操作时，也必须实施这些规则。执行客户端检查是非常耗时的，而DBMS执行这些检查会相对高效。约束（constraint）管理如何插入或处理数据库数据的规则。DBMS通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，注意：具体DBMS的约束有几种不同类型的约束，每个DBMS都提供自己的支持。因此，这里给出的例子在不同的DBMS上可能有不同的反应。在进行试验之前，请参阅具体的DBMS文档。约束是在数据库中保证数据库里表中数据完整性的手段。在Oracle中使用的约束有主键约束、外键约束、唯一约束、检查约束、非空约束、默认约束6个，其中主键约束和唯一约束都被认为是唯一约束，而外键约束被认为是参照约束。主键（PrimaryKey）约束主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中的行。没有主键，要安全地update或delete特定行而不影响其他行会非常困难。表中任意列只要满足以下条件，都可以用于主键：任意两行的主键值都不相同。每行都具有一个主键值（即列中不允许NULL值）。包含主键值的列从不修改或更新。（大多数DBMS不允许这么做，但如果你使用的DBMS允许这样做，好吧，千万别！）主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。外键（ForeignKey）约束外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。我们举个例子来理解外键。Orders表将录入到系统的每个订单作为一行包含其中。顾客信息存储在Customers表中。Orders表中的订单通过顾客ID与Customers表中的特定行相关联。顾客ID为Customers表的主键，每个顾客都有唯一的ID。订单号为Orders表的主键，每个订单都有唯一的订单号。Orders表中顾客ID列的值不一定是唯一的。如果某个顾客有多个订单，则有多个行具有相同的顾客ID（虽然每个订单都有不同的订单号）。同时，Orders表中顾客ID列的合法值为Customers表中顾客的ID。这就是外键的作用。在这个例子中，在Orders的顾客ID列上定义了一个外键，因此该列只能接受Customers表的主键值。提示：外键有助防止意外删除除帮助保证引用完整性外，外键还有另一个重要作用。在定义外键后，DBMS不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。有的DBMS支持称为级联删除（cascadingdelete）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从Customers表中删除某个顾客，则任何关联的订单行也会被自动删除。唯一（unique）约束唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。表可包含多个唯一约束，但每个表只允许一个主键。唯一约束列可包含NULL值。唯一约束列可修改或更新。唯一约束列的值可重复使用。与主键不一样，唯一约束不能用来定义外键。每个雇员都有唯一的社保号，但我们并不想用它作主键，因为它太长（而且我们也不想使该信息容易利用）。因此，每个雇员除了其社保号外还有唯一的雇员ID（主键）。雇员ID是主键，可以确定它是唯一的。你可能还想使DBMS保证每个社保号也是唯一的（保证输入错误不会导致使用他人号码）。可以通过在社保号列上定义UNIQUE约束做到。检查（check）约束检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。只允许特定的值。例如，在性别字段中只允许M或F。换句话说，数据类型限制了列中可保存的数据的类型。检查约束在数据类型内又做了进一步的限制，这些限制极其重要，可以确保插入数据库的数据正是你想要的数据。不需要依赖于客户端应用程序或用户来保证正确获取它，DBMS本身将会拒绝任何无效的数据。非空（notnull）约束非空约束是用来约束表中的列不允许为空的。例如，在员工信息表中员工身份证号码列，要求员工必须输入时，可以使用非空约束来保证该列不能为空。默认（default）约束插入数据没有赋值时，给一个默认值。事务和锁事务和锁是两个联系非常紧密的概念，它们保证了数据库的一致性。由于数据库是一个可以由多个用户共享的资源，因此当多个用户并发地存取数据时，就要保证数据的准确性。事务和锁就完成了这项功能。1.什么是事务我们可以把事务理解成一组SQL语句的集合，这样描述可能不太容易理解，不要着急，我们先大概的描述一下理论，然后再进行形象的举例。事务可以只包含一条SQL语句，也可以包含多条复杂的SQL语句，事务中的所有SQL语句被当做一个操作单元，换句话说，事务中的SQL语句要么都执行成功，要么全部执行失败，事务内的SQL语句被当做一个整体，被当做一个原子进行操作。1.1.事务的ACID特性事务有4个特性，它们分别是原子性、一致性、隔离性、持久性。原子性(atomicity)整个事务中的所有操作要么全部执行成功，要么全部执行失败后回滚到最初状态。事务的原子性是指，事务中程序是数据库的逻辑工作单位，它对数据的修改要么全部执行，要么完全不执行。原子也意味着不可分割，不管有多少程序，只要在同一个事务中，那么它们就是一个整体，如果都执行成功才意味着该事务成功，而有一个操作失败，那么同一个事务中的其他操作即使执行成功也没有用，事务会使其全部撤销。一致性(consistency)数据库总是从一个一致性状态转为另一个一致性状态。事务的一致性指事务执行的前后数据库都必须处于一致性状态，它是相对脏读而言的。只有在事务完成后才能被所有使用者看见，保证了数据的完整性。例如在银行转账时，从A账户取款但没有放到B账户中时数据是不一致的，同时也是不完整的，其他使用者此时不能看到A中修改后的数据，只有存到B账户中，交易完成并提交事务，这时才算数据一致，所有用户也会看到修改后的数据。隔离性(isolation)一个事务在提交之前所做出的的操作是否能为其他事务可见，由于不同的场景需求不同，所以针对隔离性来说，有不同的隔离级别。隔离性是指并发事务之间不能相互的干扰。也就是说，一个事务操作的数据不会被其他事务看到和操作。持久性(durability)事务一旦提交，事务所做出的修改将会永久保存，此时即使数据库崩溃，修改的数据也不会丢失。事务的提交很重要，但不建议频繁地提交事务，因为每次提交事务都需要时间，如果1W行记录，每行记录都提交事务，那么事务本身将是性能的主要消耗者。所以，适当地减少事务提交次数比较重要。例如，可以每1K行提交一次。对于这个问题比较经典的例子就是银行账户之间的汇款转账操作。银行有很多用户，目前，A用户账户上的余额为8000元，B用户账上的余额为5000元，现在A用户要向B用户转账1000元。那么，当转账结束以后，A用户账户上的余额应该为7000元，B账户上的余额应该为6000元。那么上述过程在数据库中应该转换为如下操作。操作1：修改A用户账户对应的余额记录，8000-1000操作2：修改B用户账户对应的余额记录，5000+1000上述操作好像没毛病，但是假设，如果数据库刚刚完成操作1，好巧不巧，这个时候停电了，过了两分钟，又来电了，当我们再次查看数据库时，发现A用户余额为7000，比停电之前少了1000，发现B用户的账户余额仍然为5000，与停电之前一样，出现这种情况是因为数据库只完成了操作1，而没来得及完成操作2，那么，1000块大洋凭空消失了。所以，我们应该防止这样的悲剧发生，没错，解决方法就是使用事务。我们之前说过，事务中的所有SQL语句都被当做一个整体，要么全部执行成功，要么在其中某些操作执行失败后回滚，回滚到最初的状态，就好像什么都没有发生过一样。那么利用事务的这个特性，就可以解决之前的问题，我们可以把转账的SQL语句写入到事务中，如下。事务开始updateA用户余额-1000updateB用户余额+1000提交事务（事务结束）利用事务完成上述操作，即使数据库刚刚将A用户账户余额减去1000时停电了，由于事务的特性，当再次使用数据库时，也不会出现A用户余额变为7000，B用户余额仍然为5000的情况。整个交易过程，我们看做一个事务，如果操作失败，那么该事务就会回滚，所有该事务中的操作将撤销，目标账户和源账户上的资金都不会出现变化；如果操作成功，那么将是对数据库永久的修改，即使以后服务器断电，也不会对该修改结果有影响。事务在没有提交之前可以回滚，而且在提交前当前用户可以查看已经修改的数据，但其他用户查看不到该数据，一旦事务提交就不能再撤销修改了。1.2.控制事务当一个事务被执行并成功完成时，虽然从输出结果来看目标表已经被修改了，但实际上目标表并不是立即被修改。当事务成功完成时，利用事务控制命令最终认可这个事务，可以把事务所做的修改保存到数据库，也可以撤销事务所做的修改。事务控制命令只与DML命令insert、update和delete配合使用，比如我们不会在创建表之后使用commit语句，因为当表被创建之后，它会自动被提交给数据库。也不能使用rollback语句来恢复被撤销的表。此外，还有其他类似的语句，也是不能被撤销的，例如truncate语句。所以，在运行新的命令前，最好先确认一下用户所使用的DBMS在事务方面的相关规定。当事务完成之后，事务信息被保存在数据库里的指定区域或临时回退区域。所有的修改都被保存到这个临时回退区域，直到事务控制命令出现。当事务控制命令出现时，所做的修改要么被保存到数据库，要么被放弃，然后临时回退区域被清空。事务基本控制语句有如下几个：commit：提交事务savepoint：设置保存点rollback：回滚事务rollbacktosavepoint：回滚至保存点事务和程序不同，一条语句或者多条语句甚至一段程序都可能在一个事务中，而一段程序又可以包含多个事务。事务可以根据自己的需要把一段程序分成多个组，然后把每个组都当成一个单元，而这个单元就可以理解为一个事务。代码演示：commit;savepointa1;rollbacktoa1;rollback;2.什么是锁数据库是一个庞大的多用户数据管理系统，由于在多用户的系统中，同一时刻多个用户同时操作某相同资源的情况时有发生，而在逻辑上这些用户想同时操作该资源是不可能的，而数据库中利用锁消除了多用户操作同一资源时可能产生的隐患。2.1.认识锁锁出现在数据共享的环境中，它是一种机制，在访问相同资源时，可以防止事务之间的破坏性交互。例如，在多个会话同时操作某表时，优先操作的会话需要对其锁定。事务的隔离性要求当前事务不能影响其他的事务，所以当多个会话访问相同的资源时，数据库系统会利用锁确保它们像队列一样依次进行。Oracle处理数据时用到的锁是自动获取的，我们不用对此有过多的关注，但Oracle允许我们手动锁定数据。Oracle利用很低的约束提供了最大程度的并发性，例如某会话正在修改一条记录，那么仅仅该记录会被锁定。而其他会话可以随时做读取操作，但读取的依然是修改前的数据。Oracle的锁保证了数据的完整性。例如，当一个会话对表A的某行记录进行修改时，另一个会话也来修改该行记录，在没有任何处理的情况下保留的数据会有随机性，而这种数据是没有任何意义的，为脏数据。如果此时使用了行级锁，第一个会话修改记录时封锁该行，那么第二个会话此时只能等待，这样就避免了脏数据的产生。2.2.锁的分类Oracle中分为两种模式的锁，一种是排他锁（X锁），另一种是共享锁（S锁）。排他锁也可以叫写锁。这种模式的锁防止资源的共享，用做数据的修改。假如有事务T给数据A加上该锁，那么其他的事务将不能对A加任何的锁，所以此时只允许T对该数据进行读取和修改，直到事务完成将该类型的锁释放为止。共享锁也可以叫读锁。该模式锁下的数据只能被读取，不能被修改。如果有事务T给数据A加上共享锁后，那么其他事务不能对其加排他锁，只能加共享锁。加了该锁的数据可以被并发地读取。锁是实现并发的主要手段，在数据库中应用频繁，但很多都由数据库自动管理，当事务提交后会自动释放锁。视图视图在Oracle中应用相当普遍，所以也比较重要。视图在数据库中可以理解为一张虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。使用视图可以补充表结构在某些需求方面的不足，可以让开发人员更方便地查询复杂数据，还可以缩短开发周期，节省公司成本。1.什么是视图听到视图会比较陌生，实际上视图的创建和操作比较简单。在直观印象中它和表类似，但某些表的功能它不具备。根据官方的文档可以这样理解视图：它是一个基于一个表或多个表的逻辑表，视图本身不包含任何数据。通俗来说，可以把视图看成是虚拟的表，只是一个查询语句的结果，它的数据最终是从表中获取的，这些表通常称为源表或基表。当基表的数据发生变化时，视图里的数据同样发生变化。通常视图的数据源有三种情况：单一表的子集。多表操作结果集。视图的子集。2.视图的作用我们会产生疑问，既然视图被称为虚拟的表，那还用它做什么？下面就简单介绍一下视图的作用。使数据简化在表中很多数据对业务来说是冗余的，这时开发者会使用比较复杂的SQL语句得到自己想要的。实际开发中不能要求每个人都能做到这一点，所以，通常情况下由一个人把该复杂语句做成视图，其他人员直接调用该视图即可。这样对视图使用人员就简化了数据，隐藏了数据的复杂性。使数据更加独立程序开发时，大多数是程序直接访问数据库的表，当这些表的结构随着业务的变化而不得不重新设计时会影响到程序（通常表一旦设计完成就很难再做修改），所以可以使得程序直接访问视图。这样视图就可以把程序和数据库的表隔离开来，降低开发者的劳动成本。增加安全性视图可以查询表指定的列来展现给用户，而不必让使用者完全看见表的所有字段。这种情况很多是一个公司提供给其他合作伙伴查询数据的接口，而视图通常也会设成只读属性。警告：性能问题因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。索引索引用来排序数据以加快搜索和排序操作的速度。想像一本书后的索引，可以帮助你理解数据库的索引。假如要找出本书中所有的“数据类型”这个词，简单的办法是从第1页开始，浏览每一行。虽然这样做可以完成任务，但显然不是一种好的办法。浏览少数几页文字可能还行，但以这种方式浏览整部书就不可行了。随着要搜索的页数不断增加，找出所需词汇的时间也会增加。这就是书籍要有索引的原因。索引按字母顺序列出词汇及其在书中的位置。为了搜索“数据类型”一词，可在索引中找出该词，确定它出现在哪些页中。然后再翻到这些页，找出“数据类型”一词。使索引有用的因素是什么？很简单，就是恰当的排序。找出书中词汇的困难不在于必须进行多少搜索，而在于书的内容没有按词汇排序。如果书的内容像字典一样排序，则索引没有必要（因此字典就没有索引）。数据库索引的作用也一样。主键数据总是排序的，这是DBMS的工作。因此，按主键检索特定行总是一种快速有效的操作。但是，搜索其他列中的值通常效率不高。例如，如果想搜索住在某个县的客户，怎么办？因为表数据并未按县排序，DBMS必须读出表中所有行（从第一行开始），看其是否匹配。这就像要从没有索引的书中找出词汇一样。解决方法是使用索引。可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。在开始创建索引前，应该记住以下内容：索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。索引数据可能要占用大量的存储空间。并非所有数据都适合做索引。取值不多的数据（如县）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。可以在索引中定义多个列（例如，县加上城市）。这样的索引仅在以县加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。没有严格的规则要求什么应该索引，何时索引。大多数DBMS提供了可用来确定索引效率的实用程序，应该经常使用这些实用程序。提示：检查索引索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。存储过程迄今为止，我们使用的大多数SQL语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一些复杂的操作需要多条语句才能完成。例如以下的情形：为了处理订单，必须核对以保证库存中有相应的物品。如果物品有库存，需要预定，不再出售给别的人，并且减少物品数据以反映正确的库存量。库存中没有的物品需要订购，这需要与供应商进行某种交互。关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的顾客。这显然不是一个完整的例子，它甚至超出了我们所学范例的范围，但足以表达我们的意思了。执行这个处理需要针对许多表的多条SQL语句。此外，需要执行的具体SQL语句及其次序也不是固定的，它们可能会根据物品是否在库存中而变化。那么，怎样编写代码呢？可以单独编写每条SQL语句，并根据结果有条件地执行其他语句。在每次需要这个处理时（以及每个需要它的应用中），都必须做这些工作。可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。1.为什么要使用存储过程我们知道了什么是存储过程，那么为什么要使用它们呢？理由很多，下面列出一些主要的。通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问，减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。因为存储过程通常以编译过的形式存储，所以DBMS处理命令的工作较少，提高了性能。存在一些只能用在单个请求中的SQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。换句话说，使用存储过程有三个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。不同DBMS中的存储过程语法有所不同。事实上，编写真正的可移植存储过程几乎是不可能的。不过，存储过程的自我调用（名字以及数据如何传递）可以相对保持可移植。因此，如果需要移植到别的DBMS，至少客户端应用代码不需要变动。一般来说，编写存储过程比编写基本SQL语句复杂，需要更高的技能，更丰富的经验。因此，许多数据库管理员把限制存储过程的创建作为安全措施（主要受上一条缺陷的影响）。尽管有这些缺陷，存储过程还是非常有用的，并且应该使用。事实上，多数DBMS都带有用于管理数据库和表的各种存储过程。更多信息请参阅具体的DBMS文档。说明：不能编写存储过程？你依然可以使用大多数DBMS将编写存储过程所需的安全和访问权限与执行存储过程所需的安全和访问权限区分开来。这是好事情，即使你不能（或不想）编写自己的存储过程，也仍然可以在适当的时候执行别的存储过程。触发器触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的insert、update和delete操作（或组合）相关联。与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的insert操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的insert和update操作的触发器只在表上出现这些操作时执行。触发器内的代码具有以下数据的访问权：insert操作中的所有新数据；update操作中的所有新数据和旧数据；delete操作中删除的数据。根据所使用的DBMS的不同，触发器可在特定操作执行之前或之后执行。下面是触发器的一些常见用途。保证数据一致。例如，在insert或update操作中将所有州名转换为大写。基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。计算计算列的值或更新时间戳。不同DBMS的触发器创建语法差异很大，更详细的信息请参阅相应的文档。"}, "md/范式.html": {"url": "md/范式.html", "title": "范式", "keywords": "", "body": "范式—设计关系型数据库的准则关系型数据库是目前流行和使用广泛的数据库，关系型数据库的设计标准就是数据库的范式，范式分别有第一范式、第二范式、第三范式。1.第一范式—关系型数据库设计的第一步目前，只要是使用关系型数据库来设计数据库，都能够满足数据库设计的第一范式。第一范式（1NF）就是数据库表中的字段都是单一属性的，不可再分。这个单一属性可以是数据库中任何一种基本数据类型，如整型、字符型、日期型等。只要是关系型数据库都会满足第一范式。例如，一个产品信息表(product)，描述产品信息的字段有产品编号、产品名称、产品数量、产品价格、产品描述，如表3.4所示，那么这个产品信息表就满足第一范式的要求：每一个字段都是不可再分的单一属性。2.第二范式—关系型数据库设计的第二步第二范式是在第一范式的基础上进一步对关系型数据库进行规范，官方给出第二范式的定义是要求在数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖。意思就是说在第二范式中组合主键（AB）里面的A或者B与其他字段不能存在组合重复。为解决这个问题，通常的做法是不用组合主键，添加一个编号列，作为单一主键即可满足第二范式。如果不想添加编号列，就满足组合主键（AB）里面的A或者B与其他字段不能存在组合重复。例如，设计一个购物信息表，字段包括客户编号、产品名称、产品数量、产品类型、产品价格、客户类型。如果用客户编号和产品名称作为组合主键，那么在组合主键中产品名称和产品类型存在一定关系，是由产品名称决定产品的类型，所以不符合第二范式的要求，如果不按照第二范式的要求设计表，就会出现以下4个问题：数据冗余同一个产品由n个顾客购买，“产品类型”就重复n-1次；同一个顾客购买了多件产品，那么就会多次记录顾客的个人信息。更新异常若调整了某个产品的类型，数据表中所有行的“产品类型”值都要更新，否则会出现同一个产品不同类型的情况。插入异常假设新进了一个产品，暂时还没有人购买。这样，由于没有人购买，产品的名称和类型也无法记录到数据库中。删除异常假设一批顾客把已经购买完的商品退货，这些产品信息就从数据表中删除了。但是，与此同时，产品名称和产品类型等信息也被删除了。这样就导致了删除异常。为了消除数据冗余、更新异常、插入异常和删除异常，可以把现有的一个表拆分成3张表：第1张表是产品类型表，表中有产品类型、产品名称。第2张表是客户信息表，表中有客户编号、客户类型。第3张表是产品信息表，表中有产品名称、产品类型、产品价格、产品数量。3.第三范式—关系型数据库设计的第三步第三范式是在第二范式的基础上对数据库设计进行规范，第三范式的要求是数据表中不存在非关键字段对任一候选关键字段的传递函数依赖。所谓传递函数依赖，指的是如果存在A决定B、B决定C的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在依赖关系，假定员工信息表为employee（员工编号，姓名，年龄，所在部门，部门电话），使用员工编号作为员工信息的主键，那么就存在决定关系：员工编号就决定了姓名、年龄、所在部门、部门电话这些字段。从上面的关系可以看出，在表中有一个主键，数据表的设计符合第二范式的要求。但是它不符合第三范式的要求，因为存在决定关系：员工编号就决定了所在部门，所在部门又决定了所在部门的电话，那么就存在了传递函数依赖关系，即员工编号决定部门电话，那么也会出现不满足第二范式时的数据冗余和更新、插入、删除异常的情况。为了满足第三范式的要求，必须把员工信息表拆分成如下两个数据表：员工表：员工编号、姓名、年龄、所在部门；部门表：部门名称、部门电话。除了上面的三种范式以外，还有一种范式经常使用，即鲍依斯-科得范式（BCNF）。它建立在第三范式的基础上，如果数据库表中不存在任何字段对任一候选关键字段的传递函数依赖，那么就符合BCNF范式。"}, "md/E-R图.html": {"url": "md/E-R图.html", "title": "E-R图", "keywords": "", "body": "E-R图E-R（Entity-Relationship）图又叫实体-联系图，是描述现实世界的概念模型。构成E-R图的基本要素是实体、属性和联系。下面就来详细地讲解如何绘制E-R图。1.绘制E-R图的基本要素在E-R图中涉及的基本要素有实体、联系以及属性，下面就对这3个要素进行详细说明。1.1.实体（Entity）实体是客观存在并可以相互区别的事物。实体既可以是人、物，也可以是抽象的概念。例如，一个学生、一个老师、一个产品都可以认为是实体。相同类型的实体可以构成一个实体集。例如，全体学生就是一个实体集。在E-R图中实体一般用矩形表示，矩形框内写明实体的名称。例如，写一个老师的实体，如图所示。1.2.属性（Attribute）属性是实体所具有的某一特性，一个实体可由若干个属性来刻画。在E-R图中一般用椭圆形表示，并用无向边将其与相应的实体连接起来。例如，产品的名称、价格、类型等都是属性。例如，给老师实体加上属性：姓名、年龄、所教专业、所属院系，如图所示。1.3.联系（Relationship）联系，即在信息世界中反映实体内部或实体之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系。在E-R图中用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型。实体之间存在着3种联系类型，分别是一对一、一对多、多对多，它们反映到E-R图中即为相应的联系类型，即1:1、1:n和m:n。一对一关系（1:1）一对一关系是指实体集A与实体集B，A中的每一个实体至多与B实体集中一个实体有联系；反之，在实体集B中的每个实体至多与实体集A中一个实体有联系。例如，给学生排座，“学生”实体和“座位”实体之间的关系，每一个学生最多可以分得一个座位，同时每一个座位最多只能有一个学生来坐。用图形表示如图所示。一对多关系（1:n）一对多关系是指实体集A与实体集B中至少有n（n&gt;0）个实体有联系，并且实体集B中每一个实体至多与实体集A中一个实体有联系。例如，“学生”实体和“班级”实体之间的关系，一个班级里面可以有若干个学生，而每一个学生都属于这个班级。用图形表示如图所示。多对多关系（m:n）多对多关系是指实体集A中的每一个实体与实体集B中至少m（m&gt;0）个实体有联系，并且实体集B中的每一个实体与实体集A中的至少n（n&gt;0）个实体有联系。例如，顾客在商场购买商品，顾客与商品之间就是多对多的关系，每一个顾客都可以购买多种商品，而每一种商品又可以被多个顾客购买。用图形表示如图所示。其实，实体之间的这3种关系，不仅对两个实体有效，也可以表示多个实体之间的关系。2.E-R图绘制实例绘制一个网上购物系统的E-R图，在网上购物系统中简单分析出顾客、商品、商品类型、订单4个实体。下面分别绘制每个实体属性图并在最后绘制一个整体的E-R图。顾客实体属性图顾客实体主要包括用户编号、姓名、年龄、性别、身份证号、联系方式、送货地址、银行卡卡号8个属性，实体属性图如图所示。商品实体属性图商品实体主要包括商品编号、商品名称、商品价格、商品数量、商品描述5个属性，实体属性图如图所示。商品类型实体属性图商品类型实体主要包括商品类型编号和商品类型两个属性，实体属性图如图所示。订单实体属性图订单实体主要包括订单编号、送货地址、顾客姓名、是否付款、联系方式、所购商品6个属性，实体属性图如图所示。网上购物系统E-R图在绘制整体的E-R图之前，先要了解一下网上购物系统的购物流程。首先由顾客选择要购买的商品，之后把购买商品的列表生成一个订单，然后网站的售后人员会根据订单的地址送货，在这个网上购物系统里要求一个顾客每次只能生成一个订单。那么，这4个实体之间是什么关系呢？首先商品和顾客之间的关系是多对多的关系，多个商品可以被一个顾客购买，同时多个顾客也可以购买相同的商品；订单和商品之间的关系是一对多的关系，一个订单是由多个商品组成的，多个商品组成一个订单；顾客和订单之间的关系是一对一的关系，一个顾客可以生成一个订单，一个订单只能属于一个顾客；商品和商品类型之间的关系是一对一的关系，一个商品属于一种商品类型。网上购物系统的E-R图如图所示。"}, "md/Oracle数据类型.html": {"url": "md/Oracle数据类型.html", "title": "Oracle 数据类型", "keywords": "", "body": "Oracle数据类型要使用数据库来存储数据，首先就要知道这个数据库都能存储什么类型的数据。数据类型是在向数据表中存储数据前必须设定好的，就像如果要使用记事本查看文件内容，那么文件就要是文本的，不能有图片，否则图片是查看不了的，因为记事本中只能查看文本文件。官网文档-->在Oracle11g中提供的数据类型有23种，下面介绍常用的数据类型，并把数据类型分为字符型、数字型、日期类型和其他数据类型4类进行讲解。1.字符型字符型在Oracle11g中有varchar2、char、nchar、nvarchar2和long五种，它们在数据库中是以ASCII码的格式存储的。下面用一个表格来讲解每种数据类型的作用。2.数字型数字型在Oracle11g中常用的有number和float类型两种，可以用它们来表示整数和小数。3.日期类型日期类型在Oracle11g中常用的有date和timestamp两种类型，可以用它们来存放日期和时间。4.其他数据类型除了上面讲过的字符型、数字型、日期类型之外，在Oracle11g中还有存放大数据的数据类型以及存放二进制文件的数据类型。"}, "md/exercise/index.html": {"url": "md/exercise/index.html", "title": "Oracle 练习汇总", "keywords": "", "body": "Oracle练习汇总1.表结构介绍奖金表：bonus序号列名类型说明1enameVARCHAR2(50)姓名2jobVARCHAR2(20)职位3salNUMBER薪水4commNUMBER奖金（佣金）部门表：dept序号列名类型说明1DEPTNONUMBER(2)部门编号，主键2DNAMEVARCHAR2(14)部门名称3LOCVARCHAR2(13)部门位置雇员表：emp序号列名类型说明1EMPNONUMBER(4)员工编号，EMP表主键2ENAMEVARCHAR2(50)员工姓名3JOBVARCHAR2(9)员工工作4MGRNUMBER(4)员工的领导编号，引用EMPNO5HIREDATEDATE入职日期6SALNUMBER(7,2)员工工资7COMMNUMBER(7,2)员工奖金8DEPTNONUMBER(2)员工部门编号，是表DEPT的外键。薪水等级表：salgrade序号列名类型说明1GRADENUMBER等级2LOSALNUMBER此等级下最低工资3HISALNUMBER此等级下最高工资学生表：STUDENT序号列名类型说明1IDNUMBER学生的编号2NAMEVARCHAR2(50)名字成绩表：ACHIEVEMENT序号列名类型说明1IDNUMBER学生的编号2NAMENUMBER成绩成绩表：userorgz序号列名类型说明1IDNUMBER编号2USERNAMEVARCHAR2(50)用户名3MOBILEPHONENUMBER手机号码2.创建数据SQLCreateData.sql"}, "md/exercise/001.html": {"url": "md/exercise/001.html", "title": "Oracle 练习 001", "keywords": "", "body": "Oracle练习0011.题目新建一个用户tom，密码设置为love2.实例点我看答案CREATEUSERtomIDENTIFIEDBYloveACCOUNTUNLOCK;"}, "md/exercise/002.html": {"url": "md/exercise/002.html", "title": "Oracle 练习 002", "keywords": "", "body": "Oracle练习0021.题目给用户tom授权登录，访问资源的权限2.实例点我看答案GRANTCONNECT,RESOURCETOtom;"}, "md/exercise/003.html": {"url": "md/exercise/003.html", "title": "Oracle 练习 003", "keywords": "", "body": "Oracle练习0031.题目锁定tom用户的账户，使其不能登录2.实例点我看答案ALTERUSERtomACCOUNTLOCK;"}, "md/exercise/004.html": {"url": "md/exercise/004.html", "title": "Oracle 练习 004", "keywords": "", "body": "Oracle练习0041.题目给tom用户解锁2.实例点我看答案ALTERUSERtomACCOUNTUNLOCK;"}, "md/exercise/005.html": {"url": "md/exercise/005.html", "title": "Oracle 练习 005", "keywords": "", "body": "Oracle练习0051.题目收回tom用户的登录、访问资源的权限2.实例点我看答案REVOKECONNECT,RESOURCEFROMtom;"}, "md/exercise/006.html": {"url": "md/exercise/006.html", "title": "Oracle 练习 006", "keywords": "", "body": "Oracle练习0061.题目删除用户tom2.实例点我看答案DROPUSERtom;"}, "md/exercise/007.html": {"url": "md/exercise/007.html", "title": "Oracle 练习 007", "keywords": "", "body": "Oracle练习0071.题目创建表class_info字段名类型长度可选值c_id字符串20主键c_type字符串6UI、测试、开发c_position字符串20非空start_time日期c_status字符串6在读、毕业2.实例点我看答案CREATETABLEclass_info(c_idVARCHAR2(20)PRIMARYKEY,c_typeVARCHAR2(10)CHECK(c_typein(&#x27;UI&#x27;,&#x27;测试&#x27;,&#x27;开发&#x27;)),c_positionVARCHAR2(20)NOTNULL,start_timeDATE,c_statusVARCHAR2(10)CHECK(c_statusin(&#x27;在读&#x27;,&#x27;毕业&#x27;)));"}, "md/exercise/008.html": {"url": "md/exercise/008.html", "title": "Oracle 练习 008", "keywords": "", "body": "Oracle练习0081.题目把表class_info改成class_info22.实例点我看答案renameclass_infotoclass_info2;"}, "md/exercise/009.html": {"url": "md/exercise/009.html", "title": "Oracle 练习 009", "keywords": "", "body": "Oracle练习0091.题目显示薪水大于2000，且工作类别是经理的雇员信息2.实例点我看答案select*fromempewheree.sal&gt;2000ande.job=&#x27;经理&#x27;;"}, "md/exercise/010.html": {"url": "md/exercise/010.html", "title": "Oracle 练习 010", "keywords": "", "body": "Oracle练习0101.题目显示年薪大于30000，工作类别不是经理的雇员信息2.实例点我看答案select*fromempewheree.sal*12&gt;30000ande.job!=&#x27;经理&#x27;;"}, "md/exercise/011.html": {"url": "md/exercise/011.html", "title": "Oracle 练习 011", "keywords": "", "body": "Oracle练习0111.题目显示薪水在1500到3000之间，工作类别以“M”开头的雇员信息2.实例点我看答案select*fromempewheree.salbetween1500and3000ande.joblike&#x27;M%&#x27;;"}, "md/exercise/012.html": {"url": "md/exercise/012.html", "title": "Oracle 练习 012", "keywords": "", "body": "Oracle练习0121.题目显示佣金为空并且部门号为20或30的雇员信息2.实例点我看答案select*fromempewheree.commisnulland(e.deptno=20ore.deptno=30);select*fromempewheree.commisnullande.deptnoin(20,30);"}, "md/exercise/013.html": {"url": "md/exercise/013.html", "title": "Oracle 练习 013", "keywords": "", "body": "Oracle练习0131.题目显示佣金不为空或者部门号为20的雇员信息，要求按照薪水降序排列2.实例点我看答案select*fromempewheree.commisnotnullore.deptno=20orderbye.saldesc;"}, "md/exercise/014.html": {"url": "md/exercise/014.html", "title": "Oracle 练习 014", "keywords": "", "body": "Oracle练习0141.题目显示年薪大于30000工作类别不是经理，且部门号不是10和40的雇员信息，要求按照雇员姓名进行排序2.实例点我看答案select*fromempewheree.sal*12&gt;30000ande.job!=&#x27;经理&#x27;ande.deptnonotin(10,40)orderbye.ename;"}, "md/exercise/015.html": {"url": "md/exercise/015.html", "title": "Oracle 练习 015", "keywords": "", "body": "Oracle练习0151.题目选择在部门30中员工的所有信息2.实例点我看答案select*fromempewheree.deptno=30;"}, "md/exercise/016.html": {"url": "md/exercise/016.html", "title": "Oracle 练习 016", "keywords": "", "body": "Oracle练习0161.题目列出职位为经理的员工的编号，姓名2.实例点我看答案selecte.empno,e.enamefromempewheree.job=&#x27;经理&#x27;;"}, "md/exercise/017.html": {"url": "md/exercise/017.html", "title": "Oracle 练习 017", "keywords": "", "body": "Oracle练习0171.题目找出部门10中的经理和部门20中的普通员工2.实例点我看答案select*fromempewhere(e.deptno=10ande.job=&#x27;经理&#x27;)or(e.deptno=20ande.job=&#x27;普通员工&#x27;);"}, "md/exercise/018.html": {"url": "md/exercise/018.html", "title": "Oracle 练习 018", "keywords": "", "body": "Oracle练习0181.题目找出部门10中既不是经理也不是普通员工，而且工资大于等于2000的员工2.实例点我看答案select*fromempewheree.deptno=10ande.jobnotin(&#x27;经理&#x27;,&#x27;普通员工&#x27;)ande.sal&gt;=2000;"}, "md/exercise/019.html": {"url": "md/exercise/019.html", "title": "Oracle 练习 019", "keywords": "", "body": "Oracle练习0191.题目找出没有奖金或者奖金低于500的员工2.实例点我看答案select*fromempewheree.commisnullore.comm&lt;500;"}, "md/exercise/020.html": {"url": "md/exercise/020.html", "title": "Oracle 练习 020", "keywords": "", "body": "Oracle练习0201.题目显示雇员姓名，根据其服务年限，将最老的雇员排在最前面2.实例点我看答案selecte.enamefromempeorderbye.hiredateasc;"}, "md/exercise/021.html": {"url": "md/exercise/021.html", "title": "Oracle 练习 021", "keywords": "", "body": "Oracle练习0211.题目找出有奖金的员工的不同工作2.实例点我看答案selectdistincte.jobfromempewheree.commisnotnull;"}, "md/exercise/022.html": {"url": "md/exercise/022.html", "title": "Oracle 练习 022", "keywords": "", "body": "Oracle练习0221.题目找出姓名中不带R这个字母的员工2.实例点我看答案select*fromempewheree.enamenotlike&#x27;%R%&#x27;;"}, "md/exercise/023.html": {"url": "md/exercise/023.html", "title": "Oracle 练习 023", "keywords": "", "body": "Oracle练习0231.题目显示所有员工，按工作降序排列，若相同，则按工资升序排序2.实例点我看答案select*fromempeorderbye.jobdesc,e.salasc;"}, "md/exercise/024.html": {"url": "md/exercise/024.html", "title": "Oracle 练习 024", "keywords": "", "body": "Oracle练习0241.题目查找出不属于任何部门的员工2.实例点我看答案select*fromempewheree.deptnoisnull;"}, "md/exercise/025.html": {"url": "md/exercise/025.html", "title": "Oracle 练习 025", "keywords": "", "body": "Oracle练习0251.题目创建一查询，显示与BLAKE在同一部门工作的雇员的姓名和受雇日期、部门编号，但是BLAKE不包含在内。2.实例点我看答案selecte.ename,e.hiredate,e.deptnofromempejoinempe1one.deptno=e1.deptnoande1.ename=&#x27;BLAKE&#x27;wheree.ename!=&#x27;BLAKE&#x27;;"}, "md/exercise/026.html": {"url": "md/exercise/026.html", "title": "Oracle 练习 026", "keywords": "", "body": "Oracle练习0261.题目显示位置在达拉斯的部门内的雇员姓名、工作。2.实例点我看答案selecte.ename,e.jobfromempejoindeptdone.deptno=d.deptnoandd.loc=&#x27;达拉斯&#x27;;"}, "md/exercise/027.html": {"url": "md/exercise/027.html", "title": "Oracle 练习 027", "keywords": "", "body": "Oracle练习0271.题目显示被KING直接管理的雇员的姓名以及薪水。2.实例点我看答案selecte.ename,e.salfromempejoinempe1one.mgr=e1.empnoande1.ename=&#x27;KING&#x27;;"}, "md/exercise/028.html": {"url": "md/exercise/028.html", "title": "Oracle 练习 028", "keywords": "", "body": "Oracle练习0281.题目创建一查询，显示能获得与SCOTT一样薪水的其他雇员的姓名、受雇日期以及薪水。2.实例点我看答案selecte.ename,e.hiredate,e.salfromempejoinempe1one.sal=e1.salande1.ename=&#x27;SCOTT&#x27;wheree.ename!=&#x27;SCOTT&#x27;;"}, "md/exercise/029.html": {"url": "md/exercise/029.html", "title": "Oracle 练习 029", "keywords": "", "body": "Oracle练习0291.题目查找出工资等级不为4级的员工的员工名字，部门名字，部门位置。2.实例点我看答案selecte.ename,d.dname,d.loc,s.gradefromempejoinsalgradesone.salbetweens.losalands.hisalands.grade!=4leftjoindeptdone.deptno=d.deptno;"}, "md/exercise/030.html": {"url": "md/exercise/030.html", "title": "Oracle 练习 030", "keywords": "", "body": "Oracle练习0301.题目找出每个月倒数第三天受雇的员工（如：2009-5-29）2.实例点我看答案select*fromempewheree.hiredate=last_day(e.hiredate)-2;"}, "md/exercise/031.html": {"url": "md/exercise/031.html", "title": "Oracle 练习 031", "keywords": "", "body": "Oracle练习0311.题目找出25年前雇的员工2.实例点我看答案select*fromempewhere(sysdate-e.hiredate)/12/30&gt;25;select*fromempewheremonths_between(sysdate,e.hiredate)/12&gt;25;select*fromempewhereadd_months(sysdate,-25*12)&gt;=e.hiredate;"}, "md/exercise/032.html": {"url": "md/exercise/032.html", "title": "Oracle 练习 032", "keywords": "", "body": "Oracle练习0321.题目所有员工名字前加上Dear,并且名字首字母大写2.实例点我看答案selecte.ename,&#x27;Dear&#x27;||initcap(e.ename)fromempe;selecte.ename,concat(&#x27;Dear&#x27;,initcap(e.ename))fromempe;"}, "md/exercise/033.html": {"url": "md/exercise/033.html", "title": "Oracle 练习 033", "keywords": "", "body": "Oracle练习0331.题目找出姓名为5个字符的员工2.实例点我看答案select*fromempewherelength(e.ename)=5;"}, "md/exercise/034.html": {"url": "md/exercise/034.html", "title": "Oracle 练习 034", "keywords": "", "body": "Oracle练习0341.题目显示所有员工的姓名的第一个字2.实例点我看答案selecte.ename,substr(e.ename,1,1)fromempe;"}, "md/exercise/035.html": {"url": "md/exercise/035.html", "title": "Oracle 练习 035", "keywords": "", "body": "Oracle练习0351.题目找到2月份受雇的员工2.实例点我看答案select*fromempewhereto_char(e.hiredate,&#x27;mm&#x27;)=2;"}, "md/exercise/036.html": {"url": "md/exercise/036.html", "title": "Oracle 练习 036", "keywords": "", "body": "Oracle练习0361.题目对薪水是2000元以下的员工进行查询，如果没有发奖金，每人奖金100元。2.实例点我看答案selectename,job,sal,nvl(comm,100)fromempwheresal&lt;2000;"}, "md/exercise/037.html": {"url": "md/exercise/037.html", "title": "Oracle 练习 037", "keywords": "", "body": "Oracle练习0371.题目对EMP表中薪水为2000元以下的员工进行查询，如果没有奖金，则显示奖金为200元，如果有奖金，则在原来的奖金基础上加100元。2.实例点我看答案selectename,job,sal,nvl2(comm,comm+100,200)&quot;comm&quot;fromempwheresal&lt;2000;"}, "md/exercise/038.html": {"url": "md/exercise/038.html", "title": "Oracle 练习 038", "keywords": "", "body": "Oracle练习0381.题目列出至少有一个员工的所有部门2.实例点我看答案select*fromdeptdwhered.deptnoin(selecte.deptnofromempegroupbye.deptnohavingcount(e.ename)&gt;0);"}, "md/exercise/039.html": {"url": "md/exercise/039.html", "title": "Oracle 练习 039", "keywords": "", "body": "Oracle练习0391.题目查询出KING所在部门的工作年限最大的员工名字2.实例点我看答案selecte.ename,e.hiredate,e.deptnofromempewheree.hiredate=(selectmin(hiredate)fromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;))ande.deptno=(selectdeptnofromempwhereename=&#x27;KING&#x27;);"}, "md/exercise/040.html": {"url": "md/exercise/040.html", "title": "Oracle 练习 040", "keywords": "", "body": "Oracle练习0401.题目查询出KING所在部门的部门号、部门名称、部门人数2.实例点我看答案selectd.deptno,d.dname,t.人数fromdeptd,(selectcount(*)人数,deptnofromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;)groupbydeptno)twhered.deptno=t.deptno;selectd.dname,d.deptno,t2.*fromdeptd,(selectt.人数,t.deptnofrom(selectcount(*)人数,deptnofromempgroupbydeptno)twheret.deptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;))t2whered.deptno=t2.deptno;selecte.deptno部门号,d.dname部门名称,(selectcount(*)from(selectdeptnofromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;)))人数fromempe,deptdwheree.deptno=d.deptnoande.ename=&#x27;KING&#x27;;"}, "md/exercise/041.html": {"url": "md/exercise/041.html", "title": "Oracle 练习 041", "keywords": "", "body": "Oracle练习0411.题目算出部门30中得到最多奖金的员工姓名2.实例点我看答案selectename,comm,deptnofromempwherecomm=(selectmax(comm)fromempwheredeptno=30)anddeptno=30;"}, "md/exercise/042.html": {"url": "md/exercise/042.html", "title": "Oracle 练习 042", "keywords": "", "body": "Oracle练习0421.题目统计各部门下平均工资大于500的部门2.实例点我看答案selectdeptno,avg(sal)fromempgroupbydeptnohavingavg(sal)&gt;500;"}, "md/exercise/043.html": {"url": "md/exercise/043.html", "title": "Oracle 练习 043", "keywords": "", "body": "Oracle练习0431.题目按部门统计员工数，查出员工数最多的部门的第二名到第五名（列出部门名字，部门位置）2.实例点我看答案selectd.dname,d.loc,d.deptnofromdeptd,(selectrownumno,deptnofrom(selectcount(*)人数,deptnofromempgroupbydeptnoorderby人数desc))ewheree.nobetween2and5ande.deptno=d.deptno;"}, "md/exercise/044.html": {"url": "md/exercise/044.html", "title": "Oracle 练习 044", "keywords": "", "body": "Oracle练习0441.题目查找出部门10和部门20中，工资最高第3名到第5名的员工的员工名字，部门名字，部门位置2.实例点我看答案selectd.dname,d.loc,e.enamefromdeptd,(selectename,sal,deptno,rownumnofrom(select*fromempwheredeptnoin(10,20)orderbysaldesc))ewhered.deptno=e.deptnoande.nobetween3and5;"}, "md/exercise/045.html": {"url": "md/exercise/045.html", "title": "Oracle 练习 045", "keywords": "", "body": "Oracle练习0451.题目从EMP表中查询如果其工资大于3500，则显示高工资。工资大于2000小于等于3500，则显示中等工资。工资小于等于2000的则显示低等工资。2.实例点我看答案selecte.ename,e.sal,(casewhene.sal&gt;3500then&#x27;高工资&#x27;whene.sal&gt;2000then&#x27;中等工资&#x27;else&#x27;低等工资&#x27;end)工资等级fromempe;"}, "md/exercise/046.html": {"url": "md/exercise/046.html", "title": "Oracle 练习 046", "keywords": "", "body": "Oracle练习0461.题目已知有如下数据表：A月份|部门|业绩--|--|--一月份|A|10一月份|B|10一月份|C|5二月份|A|8二月份|B|9三月份|A|8写出相应SQL，得到以下结果集：部门|一月份|二月份|三月份--|--|--|--A|10|8|8B|10|9|0C|5|0|02.实例点我看答案select部门,max(case月份when&#x27;一月份&#x27;then业绩else0end)一月份,max(case月份when&#x27;二月份&#x27;then业绩else0end)二月份,max(case月份when&#x27;三月份&#x27;then业绩else0end)三月份fromAgroupby部门;"}, "md/exercise/047.html": {"url": "md/exercise/047.html", "title": "Oracle 练习 047", "keywords": "", "body": "Oracle练习0471.题目从EMP表中查询统计各部门工资低于（包含）2000的人数与高于2000的人数2.实例点我看答案selecte.deptno,count(casewhene.sal&lt;=2000thene.salelsenullend)&quot;&lt;=2000&quot;,count(casewhene.sal&gt;2000thene.salelsenullend)&quot;&gt;2000&quot;fromempegroupbye.deptno;"}, "md/exercise/048.html": {"url": "md/exercise/048.html", "title": "Oracle 练习 048", "keywords": "", "body": "Oracle练习0481.题目从Student表和Achievement表中查询成绩&gt;85分的学生的姓名2.实例点我看答案selects.id,s.name,a.markfromstudents,achievementawheres.id=a.idanda.mark&gt;85;"}, "md/exercise/049.html": {"url": "md/exercise/049.html", "title": "Oracle 练习 049", "keywords": "", "body": "Oracle练习0491.题目从Student表和Achievement表中查询成绩&gt;=90分的人数2.实例点我看答案selectcount(*)fromachievementawherea.mark&gt;=90;"}, "md/exercise/050.html": {"url": "md/exercise/050.html", "title": "Oracle 练习 050", "keywords": "", "body": "Oracle练习0501.题目操作Student表和Achievement表Robert此次考试考了80分，但是成绩没能录入表中，请将其成绩添加进去2.实例点我看答案insertintoachievement(id,mark)values((selectidfromstudentwherename=&#x27;Robert&#x27;),80);"}, "md/exercise/051.html": {"url": "md/exercise/051.html", "title": "Oracle 练习 051", "keywords": "", "body": "Oracle练习0511.题目操作Student表和Achievement表将Rose的成绩修改为872.实例点我看答案updateachievementaseta.mark=87wherea.id=(selects.idfromstudentswherename=&#x27;Rose&#x27;);"}, "md/exercise/052.html": {"url": "md/exercise/052.html", "title": "Oracle 练习 052", "keywords": "", "body": "Oracle练习0521.题目操作Student表和Achievement表删除Betty的记录2.实例点我看答案deletefromachievementwhereid=(selectidfromstudentwherename=&#x27;Betty&#x27;);deletefromstudentwherename=&#x27;Betty&#x27;;"}, "md/exercise/053.html": {"url": "md/exercise/053.html", "title": "Oracle 练习 053", "keywords": "", "body": "Oracle练习0531.题目查询userorgz表，统计出有手机号码重复的手机号码以及重复个数，并根据重复数量降序排序且手机重复个数必须大于12.实例点我看答案selectmobilephone,count(*)fromuserorgzgroupbymobilephonehavingcount(*)&gt;1orderbycount(*)desc;"}, "md/exercise/选择题.html": {"url": "md/exercise/选择题.html", "title": "Oracle 选择题", "keywords": "", "body": "Oracle选择题1.题目SQL指的是？A.StrongQuestionLanguageB.StructuredQuestionLanguageC.StructuredQueryLanguage哪个SQL语句用于从数据库中提取数据？A.SELECTB.OPENC.GETD.EXTRACT哪条SQL语句用于更新数据库中的数据？A.UPDATEB.SAVEC.SAVEASD.MODIFY哪条SQL语句用于删除数据库中的数据？A.REMOVEB.DELETEC.COLLAPSE哪条SQL语句用于在数据库中插入新数据？A.ADDNEWB.INSERTNEWC.INSERTINTOD.ADDRECORD使用SQL，如何从名为“Persons”的表中选择名为“FirstName”的列？A.EXTRACTFirstNameFROMPersonsB.SELECTFirstNameFROMPersonsC.SELECTPersons.FirstName使用SQL，如何从名为“Persons”的表中选择所有列？A.SELECTPersonsB.SELECT*.PersonsC.SELECT[all]FROMPersonsD.SELECT*FROMPersons使用SQL，如何从名为“Persons”的表中选择“FirstName”列的值为“Peter”的所有记录？A.SELECT[all]FROMPersonsWHEREFirstName='Peter'B.SELECT[all]FROMPersonsWHEREFirstNameLIKE'Peter'C.SELECT*FROMPersonsWHEREFirstName='Peter'D.SELECT*FROMPersonsWHEREFirstName&lt;&gt;'Peter'使用SQL，如何从名为“Persons”的表中选择所有记录，其中“FirstName”列的值以“a”开头？A.SELECT*FROMPersonsWHEREFirstNameLIKE'％a'B.SELECT*FROMPersonsWHEREFirstName='％a％'C.SELECT*FROMPersonsWHEREFirstName='a'D.SELECT*FROMPersonsWHEREFirstNameLIKE'a％'如果列出的任何条件为真，OR运算符将显示一条记录。如果列出的所有条件都为真，AND运算符将显示一条记录A.TrueB.False使用SQL，如何在表Persons中选择FirstName等于Peter而LastName等于Jackson的所有记录？A.SELECTFirstName='Peter',LastName='Jackson'FROMPersonsB.SELECT*FROMPersonsWHEREFirstName='Peter'ANDLast-Name='Jackson'C.SELECT*FROMPersonsWHEREFirstName&lt;&gt;'Peter'ANDLast-Name&lt;&gt;'Jackson'使用SQL，如何按字母顺序选取Persons表中LastName介于（包含）Hansen和Pettersen的所有记录？A.SELECTLastName&gt;'Hansen'ANDLastName&lt;'Pettersen'FROMPersonsB.SELECT*FROMPersonsWHERELastNameBETWEEN'Hansen'AND'Pet-tersen'C.SELECT*FROMPersonsWHERELastName&gt;'Hansen'ANDLast-Name&lt;'Pettersen'哪条SQL语句可返回唯一不同的值？A.SELECTDISTINCTB.SELECTDIFFERENT哪个SQL关键词用于对结果集进行排序？A.SORTB.ORDERC.ORDERBYD.SORTBY使用SQL，如何根据&quot;FirstName&quot;列降序地从&quot;Persons&quot;表返回所有记录？A.SELECT*FROMPersonsSORTBY'FirstName'DESCB.SELECT*FROMPersonsSORT'FirstName'DESCC.SELECT*FROMPersonsORDERFirstNameDESCD.SELECT*FROMPersonsORDERBYFirstNameDESC使用SQL，如何向&quot;Persons&quot;表插入新的记录？A.INSERT('Jimmy','Jackson')INTOPersonsB.INSERTVALUES('Jimmy','Jackson')INTOPersonsC.INSERTINTOPersonsVALUES('Jimmy','Jackson')使用SQL，如何向&quot;Persons&quot;表中的&quot;LastName&quot;列插入&quot;Olsen&quot;？A.INSERTINTOPersons(LastName)VALUES('Olsen')B.INSERT('Olsen')INTOPersons(LastName)C.INSERTINTOPersons('Olsen')INTOLastName使用SQL，如何把&quot;Persons&quot;表中&quot;LastName&quot;列的&quot;Hansen&quot;改为&quot;Nilsen&quot;？A.UPDATEPersonsSETLastName='Hansen'INTOLastName='Nilsen'B.MODIFYPersonsSETLastName='Hansen'INTOLastName='NilsenC.UPDATEPersonsSETLastName='Nilsen'WHERELastName='Hansen'D.MODIFYPersonsSETLastName='Nilsen'WHERELastName='Hansen'使用SQL，如何在&quot;Persons&quot;表中删除&quot;FirstName&quot;等于&quot;Peter&quot;的纪录？A.DELETEFirstName='Peter'FROMPersonsB.DELETEROWFirstName='Peter'FROMPersonsC.DELETEFROMPersonsWHEREFirstName='Peter'使用SQL，如何返回&quot;Persons&quot;表中记录的数目？A.SELECTNO(*)FROMPersonsB.SELECTCOUNT(*)FROMPersonsC.SELECTLEN(*)FROMPersonsD.SELECTCOLUMNS(*)FROMPersons哪个操作符用于选择范围内的值？A.BETWEENB.RANGEC.WITHINNOTNULL约束强制约束列不接受空值。A.FalseB.True哪个操作符用于在列中模糊搜索？A.GETB.LIKEC.FROM哪个SQL语句用于在数据库中创建表？A.CREATEDATABASETABLEB.CREATEDBC.CREATEDATABASETABD.CREATETABLE2.答案点我看答案12345678910CAABCBDCDA11121314151617181920BBACDCACCB21222324ABBD"}}