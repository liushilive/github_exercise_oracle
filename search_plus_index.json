{"index.html": {"url": "index.html", "title": "介绍", "keywords": "", "body": "Oracle相关"}, "md/index.html": {"url": "md/index.html", "title": "Oracle 部署", "keywords": "", "body": "Oracle部署局域网内部环境使用非局域网内部环境请参考外网环境部署虚拟机还原到系统安装完毕快照1.部署本地yum源rm-rf/etc/yum.repos.d/*curl-o/etc/yum.repos.d/CentOS-7.repohttp://192.168.2.251/Centos/CentOS7.repoyumcleanallyummakecache2.安装必需的安装包yuminstall-ylibaiobcflexnet-tools3.安装Oraclerpm-ivhhttp://192.168.2.251/Centos/oracle/oracle-xe-11.2.0-1.0.x86_64.rpm4.配置OracleOracleApplicationExpress的有效HTTP端口（默认值为8080）Oracle数据库侦听器的有效端口（默认为1521）SYS和SYSTEM管理员帐户密码：123456确认SYS和SYSTEM管理员帐户的密码：123456数据库在计算机启动时自动启动（下次重新引导）echo-e&quot;\\n\\n123456\\n123456\\ny&quot;|/etc/init.d/oracle-xeconfigure5.环境变量配置cat&gt;&gt;.bash_profile&lt;&lt;EOF./u01/app/oracle/product/11.2.0/xe/bin/oracle_env.shEOF让环境变量生效su-6.允许远程访问Oracle11gXEGUI进入SQL命令窗口sqlplus&quot;sys/123456assysdba&quot;&lt;&lt;EOFEXECDBMS_XDB.SETLISTENERLOCALACCESS(FALSE);EOF7.配置防火墙firewall-cmd--add-port=8080/tcp--permanent--zone=publicfirewall-cmd--add-port=1521/tcp--permanent--zone=publicfirewall-cmd--reload可通下面网址访问确认安装成功http://&lt;server-ip&gt;:8080/apex/f?p=4950:1用户名：system密码：1234568.一键部署rm-rf/etc/yum.repos.d/*curl-o/etc/yum.repos.d/CentOS-7.repohttp://192.168.2.251/Centos/CentOS7.repoyumcleanallyummakecacheyuminstall-ylibaiobcflexnet-toolsrpm-ivhhttp://192.168.2.251/Centos/oracle/oracle-xe-11.2.0-1.0.x86_64.rpmecho-e&quot;\\n\\n123456\\n123456\\ny&quot;|/etc/init.d/oracle-xeconfigurecat&gt;&gt;.bash_profile&lt;&lt;EOF./u01/app/oracle/product/11.2.0/xe/bin/oracle_env.shEOFsu-sqlplus&quot;sys/123456assysdba&quot;&lt;&lt;EOFEXECDBMS_XDB.SETLISTENERLOCALACCESS(FALSE);EOFfirewall-cmd--add-port=8080/tcp--permanent--zone=publicfirewall-cmd--add-port=1521/tcp--permanent--zone=publicfirewall-cmd--reload"}, "md/总结/语法总结.html": {"url": "md/总结/语法总结.html", "title": "Oracle 语法总结", "keywords": "", "body": "Oracle语法总结CREATE\\[\\textcolor{#228B22}{CREATE}\\begin{cases}\\textcolor{#228B22}{USER}\\space\\text{用户名}\\space\\textcolor{#228B22}{IDENTIFIED\\spaceBY\\space}\\text{密码}\\space[\\textcolor{#228B22}{ACCOUNT\\spaceLOCK}|\\textcolor{#228B22}{UNLOCK}];\\\\\\textcolor{#228B22}{TABLE}\\space\\text{表名}(\\text{列名}\\space\\text{类型}\\space[\\textcolor{#228B22}{NULL}|\\textcolor{#228B22}{NOT\\spaceNULL}]\\space[\\textcolor{#228B22}{CONSTRAINT}]);\\\\[\\textcolor{#228B22}{OR\\spacereplace}]\\space[\\textcolor{#228B22}{noforce}|\\textcolor{#228B22}{force}]\\space\\textcolor{#228B22}{view}\\space\\text{视图名}\\space\\textcolor{#228B22}{AS}\\spaceSELECT\\text{查询}\\space[\\textcolor{#228B22}{with\\spaceREAD\\spaceonly}];\\\\[\\textcolor{#228B22}{UNIQUE}]\\space\\textcolor{#228B22}{INDEX}\\space\\text{索引名}\\space\\textcolor{#228B22}{ON}\\space\\text{表名}(\\text{列名}\\space[,\\space\\text{列名}…]);\\\\\\end{cases}\\]ALTER\\[\\textcolor{#228B22}{ALTER}\\begin{cases}\\textcolor{#228B22}{USER}\\space\\text{用户名}\\space{\\begin{cases}\\textcolor{#228B22}{IDENTIFIED\\spaceBY}\\space\\text{新密码};\\\\\\textcolor{#228B22}{ACCOUNT\\spaceLOCK}|\\textcolor{#228B22}{UNLOCK};\\end{cases}}\\\\\\textcolor{#228B22}{TABLE}\\space\\text{表名}\\space{\\begin{cases}\\textcolor{#228B22}{ADD}\\space{\\begin{cases}\\text{列名}\\space\\text{列类型}\\space\\text{列约束};\\\\\\textcolor{#228B22}{CONSTRAINT}\\space\\text{约束名}\\space{\\begin{cases}\\textcolor{#228B22}{PRIMARY\\spaceKEY}(\\text{列名});\\\\\\textcolor{#228B22}{FOREIGN\\spaceKEY}(\\text{列名})\\space\\textcolor{#228B22}{REFERENCES}\\space\\text{参照表}(\\text{参照列});\\\\\\textcolor{#228B22}{UNIQUE}(\\text{列名});\\\\\\textcolor{#228B22}{CHECK}(\\text{条件});\\\\\\end{cases}}\\end{cases}}\\\\\\textcolor{#228B22}{DROP}\\space{\\begin{cases}\\textcolor{#228B22}{COLUMN}\\space\\text{列名};\\\\\\textcolor{#228B22}{CONSTRAINT}\\space\\text{约束名};\\end{cases}}\\\\\\textcolor{#228B22}{MODIFY}\\space\\text{列名}\\space{\\begin{cases}\\text{数据类型};\\\\\\textcolor{#228B22}{NOT\\spaceNULL}|\\textcolor{#228B22}{NULL};\\\\\\textcolor{#228B22}{DEFAULT}\\space\\text{默认值}|\\textcolor{#228B22}{NULL};\\end{cases}}\\\\\\textcolor{#228B22}{RENAME}\\space{\\begin{cases}\\textcolor{#228B22}{TO}\\space\\text{新表名};\\\\\\textcolor{#228B22}{COLUMN}\\space\\text{列名}\\space\\textcolor{#228B22}{TO}\\space\\text{新列名};\\end{cases}}\\end{cases}}\\end{cases}\\]DROP\\[\\textcolor{#228B22}{DROP}\\begin{cases}\\textcolor{#228B22}{USER}\\space\\text{用户名}\\space[\\textcolor{#228B22}{CASCADE}];\\\\\\textcolor{#228B22}{TABLE}\\space\\text{表名};\\\\\\textcolor{#228B22}{VIEW}\\space\\text{视图名};\\\\\\textcolor{#228B22}{INDEX}\\space\\text{索引名};\\\\\\end{cases}\\]语法结构：查询SELECT[DISTINCT]*|列|表达式FROMAJOINB--内连接ON表之间关联的条件RIGHTJOINC--右外连接ON表之间关联的条件LEFTJOIND--左外连接ON表之间关联的条件FULLJOINE--全连接ON表之间关联的条件WHERE结果筛选条件GROUPBY分组列HAVING分组后结果筛选ORDERBY排序列[ASC|DESC];语法结构：创建用户CREATEUSER用户名IDENTIFIEDBY口令[ACCOUNTLOCK|UNLOCK];语法结构：修改用户的密码ALTERUSER用户名IDENTIFIEDBY新密码;语法结构：修改用户处于锁定（非锁定）状态ALTERUSER用户名ACCOUNTLOCK|UNLOCK;语法结构：删除用户DROPUSER用户名CASCADE;语法结构：授予权限GRANT角色|权限TO用户|角色;语法结构：回收权限REVOKE角色|权限FROM用户|角色;语法结构：创建表CREATETABLE表名(列名1类型[NULL|NOTNULL][CONSTRAINT],类名2类型);语法结构：修改表名RENAME原表名TO新表名;语法结构：添加列ALTERTABLE表名ADD列名列类型列约束;语法结构：删除列ALTERTABLE表名DROPCOLUMN列名;语法结构：删除表DROPTABLE表名;语法结构：添加约束ALTERTABLE表名ADDCONSTRAINT约束名约束内容;语法结构：删除约束ALTERTABLE表名DROPCONSTRAINT约束名;语法结构：数据插入INSERTINTO表名(列名1，列名2……)VALUES(值1，值2……)语法结构：更新数据UPDATE表名SET列名1=值,列名2=值WHERE条件;语法结构：删除数据DELETEFROM表名WHERE条件;语法结构：删除全部数据！！无法回滚，高危！TRUNCATETABLE表名;"}, "md/概念/index.html": {"url": "md/概念/index.html", "title": "Oracle 概念", "keywords": "", "body": "Oracle概念"}, "md/系统结构/系统结构概述.html": {"url": "md/系统结构/系统结构概述.html", "title": "系统结构概述", "keywords": "", "body": "Oracle数据库系统结构概述官方参考资料Oracle数据库由数据库存储结构和数据库实例两部分构成。数据库数据库是位于磁盘上的一组文件，用于存储数据。这些文件可以独立于数据库实例而存在。数据库实例实例是一组管理数据库文件的内存结构。该实例由一个共享内存区域（称为系统全局区域SGA）和一组后台进程组成。实例可以独立于数据库文件而存在。下图显示了数据库及其实例。对于与实例的每个用户连接，客户端进程将运行该应用程序。每个客户端进程都与自己的服务器进程相关联。服务器进程具有自己的专用会话内存，称为程序全局区域PGA。其中存储结构包括物理存储结构和逻辑存储结构，是数据存储及空间分配的基础；实例是构成Oracle数据库的软件结构，包括内存结构和后台进程，是数据库运行与管理的基础。Oracle数据库由存放在磁盘上的数据库DB和对磁盘上的数据库进行管理的数据库管理系统DBMS两部分构成，分别对应着数据库的存储结构和软件结构。Oracle数据库的存储结构（StorageStructure）分为物理存储结构和逻辑存储结构两种，分别描述了在操作系统中和数据库系统内部数据的组织与管理方式。其中，物理存储结构表现为操作系统中一系列文件，逻辑存储结构是对物理存储结构的逻辑组织与管理。Oracle数据库的软件结构，即Oracle实例（Instance），包括内存结构与后台进程结构两部分。图描述了Oracle数据库内存结构、后台进程结构、存储结构之间的关系。从图中可以看出，用户的所有操作都是通过实例完成的，首先在内存结构中进行，在一定条件下由数据库的后台进程结构写入数据库的物理存储结构做永久保存。"}, "md/系统结构/存储结构.html": {"url": "md/系统结构/存储结构.html", "title": "存储结构", "keywords": "", "body": "存储结构概述Oracle数据库的存储结构分为物理存储结构和逻辑存储结构两种。物理存储结构主要用于描述在Oracle数据库外部数据的存储，即在操作系统层面中如何组织和管理数据，与具体的操作系统有关。逻辑存储结构主要描述Oracle数据库内部数据的组织和管理方式，即在数据库管理系统的层面中如何组织和管理数据，与操作系统没有关系。物理存储结构具体表现为一系列的操作系统文件，是可见的；而逻辑存储结构是物理存储结构的抽象体现，是不可见的，可以通过查询数据库数据字典了解逻辑存储结构信息。Oracle数据库的物理存储结构与逻辑存储结构既相互独立又相互联系，如图所示。从图中可以看出数据库物理存储结构与逻辑存储结构的基本关系。一个数据库在物理上包含多个数据文件，在逻辑上包含多个表空间。一个表空间包含一个或多个数据文件，一个数据文件只能从属于某个表空间。数据库的逻辑块由一个或多个操作系统块构成。一个逻辑区只能从属于某一个数据文件，而一个数据文件可包含一个或多个逻辑区。1.物理存储结构概述Oracle数据库的物理存储结构是由一系列操作系统文件组成的，存放于物理磁盘上，是数据库的实际存储单元。这些文件主要包括数据文件、控制文件、重做日志文件、归档文件、初始化参数文件、跟踪文件、告警文件等。每种文件都存储特定内容的信息，其数量也因文件类型不同而不同。数据文件：是数据库中所有数据的实际存储空间，所有数据文件的大小和构成了数据库的大小。控制文件：记录数据库结构信息的重要的二进制文件，由Oracle系统进行读/写操作，DBA不能直接操作控制文件。重做日志文件：是以重做记录的形式记录、保存用户对数据库所进行的变更操作，是数据库中最重要的物理文件。归档日志文件：是历史联机重做日志文件的集合，是联机重做日志文件被覆盖之前备份的副本。初始化参数文件：是数据库启动过程所必需的文件，记录了数据库显式参数的设置。数据库启动的第一步就是根据初始化参数文件中的设置，创建并启动实例，即分配内存空间、启动后台进程。跟踪文件：是数据库中重要的诊断文件，是获取数据库信息的重要工具，对管理数据库的实例起着至关重要的作用。跟踪文件中包含数据库系统运行过程中所发生的重大事件的有关信息，可以为数据库运行故障的解决提供重要信息。告警文件：是数据库中重要的诊断文件，记录数据库在启动、关闭和运行期间后台进程的活动情况。2.逻辑存储结构概述Oracle数据库的逻辑存储结构是从逻辑的角度来分析数据库的构成的，也就是数据库创建后利用逻辑概念来描述Oracle数据库内部数据的组织和管理形式。在操作系统中，没有数据库逻辑存储结构信息，而只有物理存储结构信息。数据库的逻辑存储结构概念存储在数据库的数据字典中，可以通过数据字典查询逻辑存储结构信息。Oracle数据库的逻辑存储结构分为Oracle数据块（OracleDATEBlock）、区（Extent）、段（Segment）和表空间（Tablespace）4种，它们之间的关系如图所示。一个或多个连续的Oracle数据块构成区，一个或多个区构成段，一个或多个段构成表空间，所有表空间构成数据库。Oracle数据块Oracle数据块是数据库中最小的逻辑存储单元，是数据库执行输入、输出操作的最小单位，由一个或者多个操作系统块构成。在Oracle11g数据库中，数据块分为标准块和非标准块两种，其中标准块由数据库初始化参数DB_BLOCK_SIZE设置，其大小不可更改。Oracle数据库的默认数据缓冲区就是由标准数据块构成的。区区是由一系列连续的数据块构成的逻辑存储单元，是存储空间分配的最小单位。当创建一个数据库对象时，Oracle为对象分配若干个区，以构成一个段来为对象提供初始的存储空间。当段中已分配的区都写满后，Oracle会为段分配一个新区，以容纳更多的数据。构成一个段的所有区只能在一个文件中。在Oracle数据库中，引入区的目的是为了提高系统存储空间分配的效率，以区为单位的存储空间分配大大减少了磁盘分配的次数。段段是由一个或多个连续或不连续的区组成的逻辑存储单元，用于存储特定的、具有独立存储结构的数据库对象。根据存储对象类型不同，分为表段、索引段、临时段和回退段4类。表段，又称数据段，用来存储表或簇的数据，可以细分为普通表段（TABLE）、分区表段（TABLEPartition）、簇段（Cluster）、索引化表段（INDEX-organizedTABLE）。索引段用来存放索引数据，包括ROWID和索引键值。临时段是进行查询、排序等操作时，如果内存空间不足，用于保存SQL语句在解释和执行过程中产生的临时数据。会话结束时，为该操作分配的临时段将被释放。回退段用于保存数据库的回退信息，包含当前未提交事务所修改的数据的原始版本。利用回退段中保存的回退信息，可以实现事务回滚、数据库恢复、数据的读一致性和闪回查询。表空间表空间是Oracle数据库最大的逻辑存储单元，数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小。在Oracle数据库中，存储结构管理主要就是通过对表空间的管理来实现的。表空间与数据库文件直接关联，一个表空间包含一个或多个数据文件，一个数据文件只能从属于某一个表空间，数据库对象就是存储在表空间对应的一个或多个数据文件中。表空间根据存储数据的类型不同，分为系统表空间和非系统表空间两类。系统表空间主要存放数据库的系统信息，如数据字典信息、数据库对象定义信息、数据库组件信息等。非系统表空间又分为撤销表空间、临时表空间和用户表空间等。其中，撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息，用户表空间用于存储用户的业务数据。Oracle11g数据库在创建时会自动创建6个表空间，见表3-1。Oracle11g数据库自动创建的表空间名称类型描述SYSTEM系统表空间存放数据字典、数据库对象定义、PL/SQL程序源代码等系统信息SYSAUX系统表空间辅助系统表空间，存储数据库组件等信息TEMP临时表空间存放临时数据，用于排序等操作UNDOTBS1撤销表空间存储、管理回退信息USERS用户表空间存放用户业务数据信息EXAMPLE示例表空间示例表空间，存放示例的数据库方案对象信息"}, "md/系统结构/内存结构.html": {"url": "md/系统结构/内存结构.html", "title": "内存结构", "keywords": "", "body": "结构概述Oracle数据库实例由一系列内存结构和后台进程组成。用户操作数据库的过程实质上是与数据库实例建立连接，然后通过实例来操作数据库的过程。用户的所有操作都在内存中进行，最后由数据库后台进程将操作结果写入各种物理文件中永久性保存。内存结构是Oracle数据库体系结构的重要组成部分，是Oracle数据库重要的信息缓存和共享区域。根据内存区域信息使用范围的不同，分为系统全局区（SystemGlobalArea，SGA）和程序全局区（ProgramGlobalArea，PGA）。1.SGASGA是由Oracle分配的共享内存结构，包含一个数据库实例的数据和控制信息。SGA数据供所有的服务器进程和后台进程共享，所以SGA又称为共享全局区（SharedGlobalArea）。用户对数据库的各种操作主要在SGA中进行。该内存区随数据库实例的创建而分配，随实例的终止而释放。SGA主要由数据高速缓冲区（DatabaseBufferCache）、共享池（SharedPool）、重做日志缓冲区（RedoLogCache）、大型池（LargePool）、Java池（JavaPool）、流池（StreamsPool）和其他结构（如固定SGA、锁管理等）组成。数据高速缓冲区数据高速缓冲区存储的是最近从数据文件中检索出来的数据，供所有用户共享。当用户要操作数据库中的数据时，先由服务器进程将数据从磁盘的数据文件中读取到数据高速缓冲区中，然后在缓冲区中进行处理。用户处理后的结果被存储在数据高速缓冲区中，最后由数据库写入进程DBWR写到硬盘的数据文件中永久保存，如图所示。根据数据缓冲区中存放的信息的不同，数据高速缓冲区分为下列4种类型。脏缓存块（DirtyBuffers）：脏缓存块中保存的是已经被修改过的数据。空闲缓存块（FreeBuffers）：空闲缓存块中不包含任何数据，它们等待后台进程或服务器进程向其中写入数据。命中缓存块（PinnedBuffers）：命中缓存块是那些正被使用的数据块，同时还有很多会话等待修改或访问的数据块。干净缓存块（CleanBuffers）：干净缓存块是指那些当前没有被使用，即将被换出内存的缓存块，这些块中的数据要么没有被修改，要么在内存中有该数据块的快照。在Oracle11g中，数据高速缓冲区由标准缓冲区和非标准缓冲区构成，两者的和决定了数据高速缓冲区大小。标准缓冲区大小由参数DB_CACHE_SIZE设定，非标准缓冲区由参数DB_nK_CACHE_SIZE设定。重做日志缓冲区重做日志缓冲区用于缓存用户对数据库进行修改操作时生成的重做记录。为了提高工作效率，重做记录并不是直接写入到重做日志文件中，而是首先被服务器进程写入重做日志缓冲区中，在一定条件下，再由日志写入进程LGWR把重做日志缓冲区的内容写入到重做日志文件中做永久性保存。在归档模式下，当重做日志切换时，由归档进程ARCH将重做日志文件的内容写入到归档文件中，如图所示。重做日志缓存区大小由初始化参数LOG_BUFFER设定。共享池共享池用于缓存最近执行过的SQL语句、PL/SQL程序和数据字典信息，是对SQL语句、PL/SQL程序进行语法分析、编译、执行的区域。共享池由库缓存（LibraryCache）和数据字典缓存（DictionaryCache）组成。库缓存Oracle执行用户提交SQL语句或PL/SQL程序之前，先要对其进行语法分析、对象确认、权限检查、执行优化等一系列操作，并生成执行计划。这一系列操作会占用一定的系统资源，如果多次执行相同的SQL语句、PL/SQL程序，都要进行如此操作的话，将浪费很多系统资源。库缓存的作用就是缓存最近被解释并执行过的SQL语句、PL/SQL程序代码正文、编译后代码以及执行计划，以提高SQL、PL/SQL程序的执行效率。当执行SQL语句或PL/SQL程序时，Oracle首先在共享池的库缓存中搜索，查看正文完全相同的SQL语句或PL/SQL程序是否已经被分析、解析、执行并缓存过。如果有，Oracle将利用缓存中的分析结果和执行计划来执行该语句，而不必重新对它进行解析，从而大大提高了系统的执行速度。数据字典缓存区数据字典缓存区中保存最常使用的数据字典信息，如数据库对象信息、账户信息、数据库结构信息等。当用户访问数据库时，可以从数据字典缓存中获得对象是否存在、用户是否有操作权限等信息，大大提高了执行效率。共享池的大小由初始化参数SHARED_POOL_SIZE设定。大型池大型池是一个可选的内存配置项，主要为Oracle共享服务器、服务器I/O进程、数据库备份与恢复操作、执行具有大量排序操作的SQL语句、执行并行化的数据库操作等需要大量缓存的操作提供内存空间。如果没有在SGA中创建大型池，上述操作所需要的缓存空间将在共享池或PGA中分配，因而会影响共享池或PGA的使用效率。大型池的大小由初始化参数LARGE_POOL_SIZE设定。Java池Java池是一个可选的内存配置项，提供对Java程序设计的支持，用于存储Java代码、Java语句的语法分析表、Java语句的执行方案和进行Java程序开发等。Java池大小由初始化参数JAVA_POOL_SIZE设定。流池流池是一个可选的内存配置项，用于对流的支持。流池大小由初始化参数STREAMS_POOL_SIZE设定。2.PGAOracle创建一个服务器进程的同时要为该服务器进程分配一个内存区，该内存区称为程序全局区（ProgramGlobalArea，PGA）。PGA是一个私有的内存区，不能共享，每个服务器进程只能访问自己的PGA，因此PGA又称为私有全局区（PrivateGlobalArea）。系统同时为每个后台进程分配私有的PGA区。所有服务器进程PGA与所有后台进程PGA大小的和，即为实例的PGA的大小。PGA随着服务器进程与后台进程的启动而分配，随着服务器进程和后台进程终止而被释放。PGA由下列4部分组成。排序区（SORTArea）：存放排序操作所产生的临时数据。游标信息区（CursorInformation）：存放执行游标操作时所产生的数据。会话信息区（SessionInformation）：保存用户会话所具有的权限、角色、性能统计信息。堆栈区（StackSpace）：用于保存会话过程中的绑定变量、会话变量等信息。"}, "md/系统结构/后台进程.html": {"url": "md/系统结构/后台进程.html", "title": "后台进程", "keywords": "", "body": "后台进程1.Oracle进程概述进程概念进程是操作系统中一个独立的可以调度的活动，用于完成指定的任务。进程与程序的区别在于：进程是动态的概念，即动态创建，完成任务后立即消亡；而程序是一个静态实体。进程强调执行过程，而程序仅仅是指令的有序集合。进程类型在Oracle数据库服务器中，进程分为用户进程（USERProcess）、服务器进程（ServerProcess）和后台进程（BackgroundProcess）3种。用户进程当用户连接数据库执行一个应用程序时，会创建一个用户进程，来完成用户所指定的任务。服务器进程Oracle服务器进程由Oracle自身创建，用于处理连接到数据库实例的用户进程所提出的请求。服务器进程主要完成以下任务：解析并执行用户提交的SQL语句和PL/SQL程序。在SGA的数据高速缓冲区中搜索用户进程所要访问的数据，如果数据不在缓冲区中，则需要从硬盘数据文件中读取所需的数据，再将它们复制到缓冲区中。将用户改变数据库的操作信息写入日志缓冲区中。将查询或执行后的结果数据返回给用户进程。后台进程为了保证Oracle数据库在任意一个时刻都可以处理多用户的并发请求，进行复杂的数据操作，而且优化系统性能，Oracle数据库启用了一些相互独立的附加进程，称为后台进程。服务器进程在执行用户进程请求时，会调用后台进程来实现对数据库的操作。2.Oracle后台进程Oracle实例的主要后台进程包括数据库写入进程（DBWR）、日志写入进程（LGWR）、检查点进程（CKPT）、系统监控进程（SMON）、进程监控进程（PMON）、归档进程（ARCH）、恢复进程（RECO）、锁进程（LCKn）、调度进程（Dnnn）等，其中前5个后台进程是必需的。数据库的后台进程随数据库实例的启动而自动启动，它们协调服务器进程的工作，优化系统的性能。可以通过初始化参数文件中参数的设置来确定启动后台进程的数量。DBWR数据库写入进程负责把数据高速缓冲区中已经被修改过的数据（脏缓存块）成批写入数据文件中永久保存，同时使数据高速缓冲区有更多的空闲缓存块，保证服务器进程将所需要的数据从数据文件中读取到数据高速缓冲区中，提高缓存命中率。当下列某个条件满足时，DBWR进程将启动，将数据高速缓冲区中的脏数据写入数据文件：服务器进程在数据高速缓存区中搜索一定数量的缓存块后，仍然没有找到可用的空闲缓存块，此时DBWR进程将被启动；检查点发生时，将启动DBWR进程；当数据高速缓冲区中LRU列表长度达到初始化参数DB_BLOCK_WRITE_BATCH指定值的一半时，DBWR进程将被启动；DBWR进程发生超时（约3s），DBWR进程将被启动。注意：DBWR进程启动的时间与用户提交事务的时间完全无关。LGWR日志写入进程负责把重做日志缓冲区的重做记录写入重做日志文件中永久保存。DBWR进程在工作之前，需要了解LGWR进程是否已经把相关的日志缓冲区中的重做记录写入重做日志文件中。如果还没有写入重做日志文件，DBWR进程将通知LGWR进程完成相应的工作，然后DBWR进程才开始写入。这样可以保证先将与脏缓存块相关的重做记录信息写入重做日志文件，然后将脏缓存块写入数据文件，即先写重做日志文件，后写数据文件。当下列事件发生时，LGWR进程会将重做日志缓冲区中的重做记录写入重做日志文件：用户通过COMMIT语句提交当前事务；重做日志缓冲区被写满三分之一；DBWR进程开始将脏缓存块写入数据文件；LGWR进程超时（约3s），LGWR进程将启动。CKPT检查点是一个事件，当该事件发生时（每隔一段时间发生），DBWR进程把数据高速缓冲区中的脏缓存块写入数据文件中，同时Oracle将对数据库控制文件和数据文件的头部的同步序号进行更新，以记录下当前的数据库结构和状态，保证数据的同步。在执行了一个检查点事件后，Oracle知道所有已提交的事务对数据库所做的更改已经全部被写入到数据文件中，此时数据库处于一个完整状态。在发生数据库崩溃后，只需要将数据库恢复到上一个检查点执行时刻即可。因此，缩短检查点执行的间隔，可以缩短数据库恢复所需的时间。CKPT进程的作用就是执行检查点，完成下列操作：更新控制文件与数据文件的头部，使其同步；触发DBWR进程，将脏缓存块写入数据文件。SMON如果由于某种原因系统崩溃了，那么SGA中任何没有来得及写入磁盘文件中的信息都将丢失。如果有些已经提交的数据还没有真正写入数据文件中就会丢失了，当数据库重新启动时，SMON进程将自动执行Oracle实例的恢复工作。除了进行数据库实例恢复外，SMON进程还具有以下功能：回收不再使用的临时空间；将各个表空间的空闲碎片合并（表空间的存储参数PCTINCREASE不为0时）。SMON进程除了在实例启动时执行一次外，在实例运行期间，它会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用SMON进程的功能，它们将随时唤醒SMON进程。PMONPMON进程的主要功能包括：负责恢复失败的用户进程或服务器进程，并且释放进程所占用的资源；清除非正常中断的用户进程留下的孤儿会话，回退未提交的事务，释放会话所占用的锁、SGA、PGA等资源；监控调度进程和服务器进程的状态，如果它们失败，则尝试重新启动它们，并释放它们所占用的各种资源。与SMON进程类似，PMON进程在实例运行期间会被定期唤醒，检查是否有工作需要它来完成。如果有其他任何进程需要使用PMON进程的功能，它们将随时唤醒PMON进程。ARCHARCH进程负责在日志切换后将已经写满的重做日志文件复制到归档目标，以防止写满的重做日志文件被覆盖。只有当数据库运行在归档模式，并且初始化参数LOG_ARCHIVE_START设置为TRUE，即启动自动归档功能时，才能启动ARCH进程；否则当重做日志文件全部被写满后，数据库将被挂起，等待DBA进行手工归档。"}, "md/系统结构/数据字典.html": {"url": "md/系统结构/数据字典.html", "title": "数据字典", "keywords": "", "body": "数据字典1.数据字典概述数据字典的内容与作用数据字典是数据库重要组成部分，是在数据库创建过程中创建的，保存了数据库系统信息以及数据库中所有的对象信息，是数据库系统运行的基础。Oracle数据库的数据字典由一系列表和视图构成，这些表和视图对于所有的用户，包括DBA，都是只读的。只有Oracle系统才可以对数据字典进行管理与维护。在Oracle数据库中，所有数据字典表和视图都属于SYS模式，存储于SYSTEM表空间中。Oracle数据字典保存数据库本身的系统信息及所有数据库对象信息，包括：各种数据库对象的定义信息，包括表、视图、索引、同义词、序列、存储过程、函数、包、触发器及其他各种对象；数据库存储空间分配信息，如为某个数据库对象分配了多少空间，已经使用了多少空间等；数据库的安全信息，包括用户、权限、角色、完整性等；数据库运行时的性能和统计信息；其他数据库本身的基本信息。数据字典除了用于Oracle进行系统管理外，对于DBA以及普通数据库用户都有着非常重要的作用。数据字典的主要用途包括：Oracle通过访问数据字典获取用户、模式对象、数据库对象定义与存储等信息，以判断用户权限合法性、模式对象存在性及存储空间的可用性等；使用DDL语句修改数据库对象后，Oracle将在数据字典中记录所做的修改；任何数据库用户都可以从数据字典只读视图中获取各种数据库对象信息；DBA可以从数据字典动态性能视图中获取数据库的运行状态，作为进行性能调整的依据。数据字典的管理与维护数据字典主要是由Oracle数据库服务器使用的，服务器通过访问数据字典基表获取用户、数据库对象、存储结构等信息，并利用这些信息进行数据库的管理与维护。只有Oracle系统可以对数据字典进行管理与维护。在Oracle数据库运行过程中，如果数据库结构发生变化，Oracle数据库服务器会及时地修改相应的数据字典以记录这些变化。当数据库中执行下列各种SQL语句操作时，Oracle数据库服务器会修改数据字典信息。DDL语句。如增加或减少表空间、增加或减少用户。DCL语句。如授予用户权限、回收用户权限。DML语句。某些DML语句，如引起表的存储空间扩展的插入、修改语句，Oracle会将磁盘上存储空间的变化信息记录到数据字典中。包括数据库管理员（DBA）在内的任何用户都不能直接使用DML语句修改数据字典中的内容。所有用户和管理员（DBA）只能通过访问数据字典视图来得到数据库的相关信息。一些数据字典视图可以被所有用户访问，而另一些只能被数据库管理员访问。2.数据字典的结构数据字典主要包括数据字典表和数据字典视图两种。根据数据字典对象的虚实性不同，分为静态的数据字典和动态数据字典两种，其中，静态数据字典在用户访问数据字典时不会发生改变，但动态数据字典是依赖数据库运行的性能的，反映数据库运行的一些内在信息，所以在访问这类数据字典时往往不是一成不变的。静态数据字典表静态数据字典表是在数据库创建过程中自动运行sql.bsq（%Oracle_HOME%\\RDBMS\\ADMIN\\sql.bsq）脚本创建的，由SYS用户所拥有，表中信息都是经过加密处理的。数据字典中的所有信息实际上都是存储在静态数据字典表中的。静态数据字典表的命名中通常包含$符号。只有Oracle才能读/写这些静态数据字典表。例如，静态数据字典表tab$。静态数据字典视图由于静态数据字典表对于用户而言是不可访问的，因此，通过对静态数据字典表进行解密和处理，创建了一系列用户可读的静态数据字典视图。在数据库创建过程中，通过自动运行catalog.sql（%Oracle_HOME%\\RDBMS\\ADMIN\\catalog.sql）脚本创建静态数据字典视图及其公共同义词，并进行授权。例如，静态数据字典视图USER_TABLES。动态数据字典表动态数据字典表是在数据库实例运行过程中由Oracle动态创建和维护的一系列“虚表”，在实例关闭时被释放。动态数据字典表中记录与数据库运行的性能相关的统计信息，因此又称为动态性能表。通常，动态性能表的命名以X$开头。动态性能表由SYS用户所拥有。例如，动态性能表X$KSPPI。动态数据字典视图在动态性能表上创建的视图称为动态数据字典视图，又称动态性能视图。所有动态性能视图命名都以V\\(开头，Oracle自动为这些视图创建了以`V\\)`开头命名的公共同义词，因此动态性能视图又称为V$视图。例如，动态性能视图V$DATAFILE。通过查询表dictionary，可以获得全部可以访问的数据字典表或视图的名称和解释；通过查询表dict_columns，可以获得全部可以访问的数据字典表或视图中字段名称和解释。例如：SQL&gt;SELECT*FROMdictionary;SQL&gt;SELECT*FROMdict_columnsWHERETABLE_NAME=&#x27;USER_TABLES&#x27;;3.数据字典的使用静态数据字典表的使用静态数据字典表只能由Oracle进行维护，用户不能对这些表进行直接操作。当用户执行DDL操作时，Oracle系统自动对相应的静态数据字典表进行操作。例如，当执行CREATETABLE、ALTERTABLE和DROPTABLE操作时，系统会自动对TAB$表进行INSERT、UPDATE和DELETE操作。静态数据字典视图的使用通常，用户通过对静态数据字典视图的查询可以获取所需要的所有数据库信息。Oracle静态数据字典视图可以分为3类，各类视图具有独特的前缀，其表示形式和含义如表所描述。静态数据字典视图分类及其含义名称前缀含义USER_包含当前数据库用户所拥有的所有的模式对象的信息ALL_包含当前数据库用户可以访问的所有的模式对象的信息DBA_包含所有数据库对象信息，只有具有DBA角色的用户才能够访问这些视图例如，查询当前用户所拥有的表的信息、可以访问的表的信息及当前数据库所有表的信息，可以分别执行下列语句：SQL&gt;SELECT*FROMUSER_TABLES;SQL&gt;SELECT*FROMALL_TABLES;SQL&gt;SELECT*FROMSYS.DBA_TABLES;注意：以USER_、ALL_开头的数据字典视图都具有与其同名公共同义词，用户可以直接访问，而以DBA_开头的数据字典视图归SYS用户所有，没有与其对应的同名公共同义词，因此非SYS用户访问时，需在DBA_视图名前加SYS前缀。动态性能表的使用动态性能表是数据库实例启动后动态创建的表，用于存放数据库运行过程中的性能相关的信息。动态性能表都属于SYS用户，Oracle使用这些表生成动态性能视图。可以通过下列语句查询当前数据库中所有的动态性能表和动态性能视图：SQL&gt;SELECTNAMEFROMV_$FIXED_TABLE;动态性能视图的使用动态性能视图是SYS用户所拥有的，在默认状况下，只有SYS用户和拥有DBA角色的用户可以访问。与静态数据字典表和视图不同，在数据库启动的不同阶段只能访问不同的动态性能视图。当数据库启动到NOMOUNT状态时，Oracle数据库打开初始化参数文件，分配SGA并启动后台进程，因此只能访问从SGA中获得信息的动态性能视图，如V$PARAMETER、V$SGA、V$SESSION、V$PROCESSE、V$INSTANCE、V$VERSION、V$OPTION等。当数据库启动到MOUNT状态时，Oracle打开控制文件，因此不仅能访问从SGA中获得信息的动态性能视图，还可以访问从控制文件中获得信息的动态性能视图，如V$LOG、V$LOGFILE、V$DATAFILE、V$CONTROLFILE、V$DATABASE、V$THREAD、V$DATAFILE_HEADER等。当数据库完全启动后，可以访问V_$fixed_table表中所有的动态性能视图。例如，利用动态性能视图查询当前数据库参数设置信息、数据文件信息。SQL&gt;SELECT*FROMV$PARAMETER;SQL&gt;SELECT*FROMDATAFILE;"}, "md/概念/数据库中的相关术语.html": {"url": "md/概念/数据库中的相关术语.html", "title": "数据库中的相关术语", "keywords": "", "body": "数据库中的相关术语在Oracle数据库中每个数据库里面都包含很多对象，主要包括表、视图、存储过程、触发器以及约束。在这儿只简单介绍一下每一个术语的含义，在后面会详细地讲解这些术语的使用。1.数据库数据库这个术语的用法很多，但就从SQL的角度来看，数据库是一个以某种有组织的方式存储的数据集合。最简单的办法是将数据库想象为一个文件柜。这个文件柜是一个存放数据的物理位置，不管数据是什么，也不管数据是如何组织的。数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。注意：误用导致混淆我们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统（即DBMS）。数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。2.表你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。表（TABLE）某种特定类型数据的结构化清单。这里的关键一点在于，存储在表中的数据是同一种类型的数据或清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中，否则以后的检索和访问会很困难。应该创建两个表，每个清单一个表。数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数据库中没有其他表具有相同的名字。说明：表名使表名成为唯一的，实际上是数据库名和表名等的组合。有的数据库还使用数据库拥有者的名字作为唯一名的一部分。也就是说，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中完全可以使用相同的表名。表具有一些特性，这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的模式（schema），模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）。模式关于数据库和表的布局及特性的信息。3.列和数据类型表由列组成。列存储表中某部分的信息。列（column）表中的一个字段。所有表都是由一个或多个列组成的。理解列的最好办法是将数据库表想象为一个网格，就像个电子表格那样。网格中每一列存储着某种特定的信息。例如，在顾客表中，一列存储顾客编号，另一列存储顾客姓名，而地址、城市、县以及邮政编码全都存储在各自的列中。提示：分解数据正确地将数据分解为多个列极为重要。例如，城市、县、邮政编码应该总是彼此独立的列。通过分解这些数据，才有可能利用特定的列对数据进行分类和过滤（如找出特定县或特定城市的所有顾客）。如果城市和县组合在一个列中，则按县进行分类或过滤就会很困难。你可以根据自己的具体需求来决定把数据分解到何种程度。例如，一般可以把门牌号和街道名一起存储在地址里。这没有问题，除非你哪天想用街道名来排序，这时，最好将门牌号和街道名分开。数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可以存储哪些数据种类。例如，如果列中存储的是数字（或许是订单中的物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。数据类型所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允许）该列中存储的数据。数据类型限定了可存储在列中的数据种类（例如，防止在数值字段中录入字符值）。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。因此，在创建表时必须特别关注所用的数据类型。注意：数据类型兼容数据类型及其名称是SQL不兼容的一个主要原因。虽然大多数基本数据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是，偶然会有相同的数据类型在不同的DBMS中具有不同的名称。对此用户毫无办法，重要的是在创建表结构时要记住这些差异。4.行表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。例如，顾客表可以每行存储一个顾客。表中的行编号为记录的编号。行（row）表中的一个记录。说明：是记录还是行？你可能听到用户在提到行时称其为数据库记录（record）。这两个术语多半是可以交替使用的，但从技术上说，行才是正确的术语。约束SQL已经改进过多个版本，成为非常完善和强大的语言。许多强有力的特性给用户提供了高级的数据处理技术，如约束。关系数据库存储分解为多个表的数据，每个表存储相应的数据。利用键来建立从一个表到另一个表的引用（由此产生了术语引用完整性（referentialintegrity））。正确地进行关系数据库设计，需要一种方法保证只在表中插入合法数据。例如，如果Orders表存储订单信息，OrderItems表存储订单详细内容，应该保证OrderItems中引用的任何订单ID都存在于Orders中。类似地，在Orders表中引用的任意顾客必须存在于Customers表中。虽然可以在插入新行时进行检查（在另一个表上执行SELECT，以保证所有值合法并存在），但最好不要这样做，原因如下：如果在客户端层面上实施数据库完整性规则，则每个客户端都要被迫实施这些规则，一定会有一些客户端不实施这些规则。在执行UPDATE和DELETE操作时，也必须实施这些规则。执行客户端检查是非常耗时的，而DBMS执行这些检查会相对高效。约束（constraint）管理如何插入或处理数据库数据的规则。DBMS通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，注意：具体DBMS的约束有几种不同类型的约束，每个DBMS都提供自己的支持。因此，这里给出的例子在不同的DBMS上可能有不同的反应。在进行试验之前，请参阅具体的DBMS文档。约束是在数据库中保证数据库里表中数据完整性的手段。在Oracle中使用的约束有主键约束、外键约束、唯一约束、检查约束、非空约束、默认约束6个，其中主键约束和唯一约束都被认为是唯一约束，而外键约束被认为是参照约束。主键（PrimaryKey）约束主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。这方便了直接或交互地处理表中的行。没有主键，要安全地UPDATE或DELETE特定行而不影响其他行会非常困难。表中任意列只要满足以下条件，都可以用于主键：任意两行的主键值都不相同。每行都具有一个主键值（即列中不允许NULL值）。包含主键值的列从不修改或更新。（大多数DBMS不允许这么做，但如果你使用的DBMS允许这样做，好吧，千万别！）主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。外键（ForeignKEY）约束外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。我们举个例子来理解外键。Orders表将录入到系统的每个订单作为一行包含其中。顾客信息存储在Customers表中。Orders表中的订单通过顾客ID与Customers表中的特定行相关联。顾客ID为Customers表的主键，每个顾客都有唯一的ID。订单号为Orders表的主键，每个订单都有唯一的订单号。Orders表中顾客ID列的值不一定是唯一的。如果某个顾客有多个订单，则有多个行具有相同的顾客ID（虽然每个订单都有不同的订单号）。同时，Orders表中顾客ID列的合法值为Customers表中顾客的ID。这就是外键的作用。在这个例子中，在Orders的顾客ID列上定义了一个外键，因此该列只能接受Customers表的主键值。提示：外键有助防止意外删除除帮助保证引用完整性外，外键还有另一个重要作用。在定义外键后，DBMS不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。有的DBMS支持称为级联删除（cascadingDELETE）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从Customers表中删除某个顾客，则任何关联的订单行也会被自动删除。唯一（unique）约束唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。表可包含多个唯一约束，但每个表只允许一个主键。唯一约束列可包含NULL值。唯一约束列可修改或更新。唯一约束列的值可重复使用。与主键不一样，唯一约束不能用来定义外键。每个雇员都有唯一的社保号，但我们并不想用它作主键，因为它太长（而且我们也不想使该信息容易利用）。因此，每个雇员除了其社保号外还有唯一的雇员ID（主键）。雇员ID是主键，可以确定它是唯一的。你可能还想使DBMS保证每个社保号也是唯一的（保证输入错误不会导致使用他人号码）。可以通过在社保号列上定义UNIQUE约束做到。检查（check）约束检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。只允许特定的值。例如，在性别字段中只允许M或F。换句话说，数据类型限制了列中可保存的数据的类型。检查约束在数据类型内又做了进一步的限制，这些限制极其重要，可以确保插入数据库的数据正是你想要的数据。不需要依赖于客户端应用程序或用户来保证正确获取它，DBMS本身将会拒绝任何无效的数据。非空（notNULL）约束非空约束是用来约束表中的列不允许为空的。例如，在员工信息表中员工身份证号码列，要求员工必须输入时，可以使用非空约束来保证该列不能为空。默认（DEFAULT）约束插入数据没有赋值时，给一个默认值。事务和锁事务和锁是两个联系非常紧密的概念，它们保证了数据库的一致性。由于数据库是一个可以由多个用户共享的资源，因此当多个用户并发地存取数据时，就要保证数据的准确性。事务和锁就完成了这项功能。1.什么是事务我们可以把事务理解成一组SQL语句的集合，这样描述可能不太容易理解，不要着急，我们先大概的描述一下理论，然后再进行形象的举例。事务可以只包含一条SQL语句，也可以包含多条复杂的SQL语句，事务中的所有SQL语句被当做一个操作单元，换句话说，事务中的SQL语句要么都执行成功，要么全部执行失败，事务内的SQL语句被当做一个整体，被当做一个原子进行操作。1.1.事务的ACID特性事务有4个特性，它们分别是原子性、一致性、隔离性、持久性。原子性(atomicity)整个事务中的所有操作要么全部执行成功，要么全部执行失败后回滚到最初状态。事务的原子性是指，事务中程序是数据库的逻辑工作单位，它对数据的修改要么全部执行，要么完全不执行。原子也意味着不可分割，不管有多少程序，只要在同一个事务中，那么它们就是一个整体，如果都执行成功才意味着该事务成功，而有一个操作失败，那么同一个事务中的其他操作即使执行成功也没有用，事务会使其全部撤销。一致性(consistency)数据库总是从一个一致性状态转为另一个一致性状态。事务的一致性指事务执行的前后数据库都必须处于一致性状态，它是相对脏读而言的。只有在事务完成后才能被所有使用者看见，保证了数据的完整性。例如在银行转账时，从A账户取款但没有放到B账户中时数据是不一致的，同时也是不完整的，其他使用者此时不能看到A中修改后的数据，只有存到B账户中，交易完成并提交事务，这时才算数据一致，所有用户也会看到修改后的数据。隔离性(isolation)一个事务在提交之前所做出的的操作是否能为其他事务可见，由于不同的场景需求不同，所以针对隔离性来说，有不同的隔离级别。隔离性是指并发事务之间不能相互的干扰。也就是说，一个事务操作的数据不会被其他事务看到和操作。持久性(durability)事务一旦提交，事务所做出的修改将会永久保存，此时即使数据库崩溃，修改的数据也不会丢失。事务的提交很重要，但不建议频繁地提交事务，因为每次提交事务都需要时间，如果1W行记录，每行记录都提交事务，那么事务本身将是性能的主要消耗者。所以，适当地减少事务提交次数比较重要。例如，可以每1K行提交一次。对于这个问题比较经典的例子就是银行账户之间的汇款转账操作。银行有很多用户，目前，A用户账户上的余额为8000元，B用户账上的余额为5000元，现在A用户要向B用户转账1000元。那么，当转账结束以后，A用户账户上的余额应该为7000元，B账户上的余额应该为6000元。那么上述过程在数据库中应该转换为如下操作。操作1：修改A用户账户对应的余额记录，8000-1000操作2：修改B用户账户对应的余额记录，5000+1000上述操作好像没毛病，但是假设，如果数据库刚刚完成操作1，好巧不巧，这个时候停电了，过了两分钟，又来电了，当我们再次查看数据库时，发现A用户余额为7000，比停电之前少了1000，发现B用户的账户余额仍然为5000，与停电之前一样，出现这种情况是因为数据库只完成了操作1，而没来得及完成操作2，那么，1000块大洋凭空消失了。所以，我们应该防止这样的悲剧发生，没错，解决方法就是使用事务。我们之前说过，事务中的所有SQL语句都被当做一个整体，要么全部执行成功，要么在其中某些操作执行失败后回滚，回滚到最初的状态，就好像什么都没有发生过一样。那么利用事务的这个特性，就可以解决之前的问题，我们可以把转账的SQL语句写入到事务中，如下。事务开始UPDATEA用户余额-1000UPDATEB用户余额+1000提交事务（事务结束）利用事务完成上述操作，即使数据库刚刚将A用户账户余额减去1000时停电了，由于事务的特性，当再次使用数据库时，也不会出现A用户余额变为7000，B用户余额仍然为5000的情况。整个交易过程，我们看做一个事务，如果操作失败，那么该事务就会回滚，所有该事务中的操作将撤销，目标账户和源账户上的资金都不会出现变化；如果操作成功，那么将是对数据库永久的修改，即使以后服务器断电，也不会对该修改结果有影响。事务在没有提交之前可以回滚，而且在提交前当前用户可以查看已经修改的数据，但其他用户查看不到该数据，一旦事务提交就不能再撤销修改了。1.2.控制事务当一个事务被执行并成功完成时，虽然从输出结果来看目标表已经被修改了，但实际上目标表并不是立即被修改。当事务成功完成时，利用事务控制命令最终认可这个事务，可以把事务所做的修改保存到数据库，也可以撤销事务所做的修改。事务控制命令只与DML命令INSERT、UPDATE和DELETE配合使用，比如我们不会在创建表之后使用COMMIT语句，因为当表被创建之后，它会自动被提交给数据库。也不能使用ROLLBACK语句来恢复被撤销的表。此外，还有其他类似的语句，也是不能被撤销的，例如TRUNCATE语句。所以，在运行新的命令前，最好先确认一下用户所使用的DBMS在事务方面的相关规定。当事务完成之后，事务信息被保存在数据库里的指定区域或临时回退区域。所有的修改都被保存到这个临时回退区域，直到事务控制命令出现。当事务控制命令出现时，所做的修改要么被保存到数据库，要么被放弃，然后临时回退区域被清空。事务基本控制语句有如下几个：commit：提交事务savepoint：设置保存点rollback：回滚事务ROLLBACKTOsavepoint：回滚至保存点事务和程序不同，一条语句或者多条语句甚至一段程序都可能在一个事务中，而一段程序又可以包含多个事务。事务可以根据自己的需要把一段程序分成多个组，然后把每个组都当成一个单元，而这个单元就可以理解为一个事务。代码演示：COMMIT;SAVEPOINTa1;ROLLBACKTOa1;ROLLBACK;2.什么是锁数据库是一个庞大的多用户数据管理系统，由于在多用户的系统中，同一时刻多个用户同时操作某相同资源的情况时有发生，而在逻辑上这些用户想同时操作该资源是不可能的，而数据库中利用锁消除了多用户操作同一资源时可能产生的隐患。2.1.认识锁锁出现在数据共享的环境中，它是一种机制，在访问相同资源时，可以防止事务之间的破坏性交互。例如，在多个会话同时操作某表时，优先操作的会话需要对其锁定。事务的隔离性要求当前事务不能影响其他的事务，所以当多个会话访问相同的资源时，数据库系统会利用锁确保它们像队列一样依次进行。Oracle处理数据时用到的锁是自动获取的，我们不用对此有过多的关注，但Oracle允许我们手动锁定数据。Oracle利用很低的约束提供了最大程度的并发性，例如某会话正在修改一条记录，那么仅仅该记录会被锁定。而其他会话可以随时做读取操作，但读取的依然是修改前的数据。Oracle的锁保证了数据的完整性。例如，当一个会话对表A的某行记录进行修改时，另一个会话也来修改该行记录，在没有任何处理的情况下保留的数据会有随机性，而这种数据是没有任何意义的，为脏数据。如果此时使用了行级锁，第一个会话修改记录时封锁该行，那么第二个会话此时只能等待，这样就避免了脏数据的产生。2.2.锁的分类Oracle中分为两种模式的锁，一种是排他锁（X锁），另一种是共享锁（S锁）。排他锁也可以叫写锁。这种模式的锁防止资源的共享，用做数据的修改。假如有事务T给数据A加上该锁，那么其他的事务将不能对A加任何的锁，所以此时只允许T对该数据进行读取和修改，直到事务完成将该类型的锁释放为止。共享锁也可以叫读锁。该模式锁下的数据只能被读取，不能被修改。如果有事务T给数据A加上共享锁后，那么其他事务不能对其加排他锁，只能加共享锁。加了该锁的数据可以被并发地读取。锁是实现并发的主要手段，在数据库中应用频繁，但很多都由数据库自动管理，当事务提交后会自动释放锁。视图视图在Oracle中应用相当普遍，所以也比较重要。视图在数据库中可以理解为一张虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。使用视图可以补充表结构在某些需求方面的不足，可以让开发人员更方便地查询复杂数据，还可以缩短开发周期，节省公司成本。1.什么是视图听到视图会比较陌生，实际上视图的创建和操作比较简单。在直观印象中它和表类似，但某些表的功能它不具备。根据官方的文档可以这样理解视图：它是一个基于一个表或多个表的逻辑表，视图本身不包含任何数据。通俗来说，可以把视图看成是虚拟的表，只是一个查询语句的结果，它的数据最终是从表中获取的，这些表通常称为源表或基表。当基表的数据发生变化时，视图里的数据同样发生变化。通常视图的数据源有三种情况：单一表的子集。多表操作结果集。视图的子集。2.视图的作用我们会产生疑问，既然视图被称为虚拟的表，那还用它做什么？下面就简单介绍一下视图的作用。使数据简化在表中很多数据对业务来说是冗余的，这时开发者会使用比较复杂的SQL语句得到自己想要的。实际开发中不能要求每个人都能做到这一点，所以，通常情况下由一个人把该复杂语句做成视图，其他人员直接调用该视图即可。这样对视图使用人员就简化了数据，隐藏了数据的复杂性。使数据更加独立程序开发时，大多数是程序直接访问数据库的表，当这些表的结构随着业务的变化而不得不重新设计时会影响到程序（通常表一旦设计完成就很难再做修改），所以可以使得程序直接访问视图。这样视图就可以把程序和数据库的表隔离开来，降低开发者的劳动成本。增加安全性视图可以查询表指定的列来展现给用户，而不必让使用者完全看见表的所有字段。这种情况很多是一个公司提供给其他合作伙伴查询数据的接口，而视图通常也会设成只读属性。警告：性能问题因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。索引索引用来排序数据以加快搜索和排序操作的速度。想像一本书后的索引，可以帮助你理解数据库的索引。假如要找出书中所有的数据类型这个词，简单的办法是从第1页开始，浏览每一行。虽然这样做可以完成任务，但显然不是一种好的办法。浏览少数几页文字可能还行，但以这种方式浏览整部书就不可行了。随着要搜索的页数不断增加，找出所需词汇的时间也会增加。这就是书籍要有索引的原因。索引按字母顺序列出词汇及其在书中的位置。为了搜索数据类型一词，可在索引中找出该词，确定它出现在哪些页中。然后再翻到这些页，找出数据类型一词。使索引有用的因素是什么？很简单，就是恰当的排序。找出书中词汇的困难不在于必须进行多少搜索，而在于书的内容没有按词汇排序。如果书的内容像字典一样排序，则索引没有必要（因此字典就没有索引）。数据库索引的作用也一样。主键数据总是排序的，这是DBMS的工作。因此，按主键检索特定行总是一种快速有效的操作。但是，搜索其他列中的值通常效率不高。例如，如果想搜索住在某个县的客户，怎么办？因为表数据并未按县排序，DBMS必须读出表中所有行（从第一行开始），看其是否匹配。这就像要从没有索引的书中找出词汇一样。解决方法是使用索引。可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。在开始创建索引前，应该记住以下内容：索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。索引数据可能要占用大量的存储空间。并非所有数据都适合做索引。取值不多的数据（如县）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。可以在索引中定义多个列（例如，县加上城市）。这样的索引仅在以县加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。没有严格的规则要求什么应该索引，何时索引。大多数DBMS提供了可用来确定索引效率的实用程序，应该经常使用这些实用程序。提示：检查索引索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整。存储过程迄今为止，我们使用的大多数SQL语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一些复杂的操作需要多条语句才能完成。例如以下的情形：为了处理订单，必须核对以保证库存中有相应的物品。如果物品有库存，需要预定，不再出售给别的人，并且减少物品数据以反映正确的库存量。库存中没有的物品需要订购，这需要与供应商进行某种交互。关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的顾客。这显然不是一个完整的例子，它甚至超出了我们所学范例的范围，但足以表达我们的意思了。执行这个处理需要针对许多表的多条SQL语句。此外，需要执行的具体SQL语句及其次序也不是固定的，它们可能会根据物品是否在库存中而变化。那么，怎样编写代码呢？可以单独编写每条SQL语句，并根据结果有条件地执行其他语句。在每次需要这个处理时（以及每个需要它的应用中），都必须做这些工作。可以创建存储过程。简单来说，存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。1.为什么要使用存储过程我们知道了什么是存储过程，那么为什么要使用它们呢？理由很多，下面列出一些主要的。通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问，减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。因为存储过程通常以编译过的形式存储，所以DBMS处理命令的工作较少，提高了性能。存在一些只能用在单个请求中的SQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。换句话说，使用存储过程有三个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。不同DBMS中的存储过程语法有所不同。事实上，编写真正的可移植存储过程几乎是不可能的。不过，存储过程的自我调用（名字以及数据如何传递）可以相对保持可移植。因此，如果需要移植到别的DBMS，至少客户端应用代码不需要变动。一般来说，编写存储过程比编写基本SQL语句复杂，需要更高的技能，更丰富的经验。因此，许多数据库管理员把限制存储过程的创建作为安全措施（主要受上一条缺陷的影响）。尽管有这些缺陷，存储过程还是非常有用的，并且应该使用。事实上，多数DBMS都带有用于管理数据库和表的各种存储过程。更多信息请参阅具体的DBMS文档。说明：不能编写存储过程？你依然可以使用大多数DBMS将编写存储过程所需的安全和访问权限与执行存储过程所需的安全和访问权限区分开来。这是好事情，即使你不能（或不想）编写自己的存储过程，也仍然可以在适当的时候执行别的存储过程。触发器触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的insert、UPDATE和DELETE操作（或组合）相关联。与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行。触发器内的代码具有以下数据的访问权：INSERT操作中的所有新数据；UPDATE操作中的所有新数据和旧数据；DELETE操作中删除的数据。根据所使用的DBMS的不同，触发器可在特定操作执行之前或之后执行。下面是触发器的一些常见用途。保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写。基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。计算计算列的值或更新时间戳。不同DBMS的触发器创建语法差异很大，更详细的信息请参阅相应的文档。"}, "md/概念/范式.html": {"url": "md/概念/范式.html", "title": "范式", "keywords": "", "body": "范式—设计关系型数据库的准则关系型数据库是目前流行和使用广泛的数据库，关系型数据库的设计标准就是数据库的范式，范式分别有第一范式、第二范式、第三范式。1.第一范式—关系型数据库设计的第一步目前，只要是使用关系型数据库来设计数据库，都能够满足数据库设计的第一范式。第一范式（1NF）就是数据库表中的字段都是单一属性的，不可再分。这个单一属性可以是数据库中任何一种基本数据类型，如整型、字符型、日期型等。只要是关系型数据库都会满足第一范式。例如，一个产品信息表(product)，描述产品信息的字段有产品编号、产品名称、产品数量、产品价格、产品描述，如表所示，那么这个产品信息表就满足第一范式的要求：每一个字段都是不可再分的单一属性。字段名数据类型产品编号整数产品名称字符型产品数量整数产品价格实型产品描述字符型2.第二范式—关系型数据库设计的第二步第二范式是在第一范式的基础上进一步对关系型数据库进行规范，官方给出第二范式的定义是要求在数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖。意思就是说在第二范式中组合主键（AB）里面的A或者B与其他字段不能存在组合重复。为解决这个问题，通常的做法是不用组合主键，添加一个编号列，作为单一主键即可满足第二范式。如果不想添加编号列，就满足组合主键（AB）里面的A或者B与其他字段不能存在组合重复。例如，设计一个购物信息表，字段包括客户编号、产品名称、产品数量、产品类型、产品价格、客户类型。如果用客户编号和产品名称作为组合主键，那么在组合主键中产品名称和产品类型存在一定关系，是由产品名称决定产品的类型，所以不符合第二范式的要求，如果不按照第二范式的要求设计表，就会出现以下4个问题：数据冗余同一个产品由n个顾客购买，产品类型就重复n-1次；同一个顾客购买了多件产品，那么就会多次记录顾客的个人信息。更新异常若调整了某个产品的类型，数据表中所有行的产品类型值都要更新，否则会出现同一个产品不同类型的情况。插入异常假设新进了一个产品，暂时还没有人购买。这样，由于没有人购买，产品的名称和类型也无法记录到数据库中。删除异常假设一批顾客把已经购买完的商品退货，这些产品信息就从数据表中删除了。但是，与此同时，产品名称和产品类型等信息也被删除了。这样就导致了删除异常。为了消除数据冗余、更新异常、插入异常和删除异常，可以把现有的一个表拆分成3张表：第1张表是产品类型表，表中有产品类型、产品名称。第2张表是客户信息表，表中有客户编号、客户类型。第3张表是产品信息表，表中有产品名称、产品类型、产品价格、产品数量。3.第三范式—关系型数据库设计的第三步第三范式是在第二范式的基础上对数据库设计进行规范，第三范式的要求是数据表中不存在非关键字段对任一候选关键字段的传递函数依赖。所谓传递函数依赖，指的是如果存在A决定B、B决定C的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在依赖关系，假定员工信息表为employee（员工编号，姓名，年龄，所在部门，部门电话），使用员工编号作为员工信息的主键，那么就存在决定关系：员工编号就决定了姓名、年龄、所在部门、部门电话这些字段。从上面的关系可以看出，在表中有一个主键，数据表的设计符合第二范式的要求。但是它不符合第三范式的要求，因为存在决定关系：员工编号就决定了所在部门，所在部门又决定了所在部门的电话，那么就存在了传递函数依赖关系，即员工编号决定部门电话，那么也会出现不满足第二范式时的数据冗余和更新、插入、删除异常的情况。为了满足第三范式的要求，必须把员工信息表拆分成如下两个数据表：员工表：员工编号、姓名、年龄、所在部门；部门表：部门名称、部门电话。除了上面的三种范式以外，还有一种范式经常使用，即鲍依斯-科得范式（BCNF）。它建立在第三范式的基础上，如果数据库表中不存在任何字段对任一候选关键字段的传递函数依赖，那么就符合BCNF范式。"}, "md/概念/E-R图.html": {"url": "md/概念/E-R图.html", "title": "E-R图", "keywords": "", "body": "E-R图E-R（Entity-Relationship）图又叫实体-联系图，是描述现实世界的概念模型。构成E-R图的基本要素是实体、属性和联系。下面就来详细地讲解如何绘制E-R图。1.绘制E-R图的基本要素在E-R图中涉及的基本要素有实体、联系以及属性，下面就对这3个要素进行详细说明。1.1.实体（Entity）实体是客观存在并可以相互区别的事物。实体既可以是人、物，也可以是抽象的概念。例如，一个学生、一个老师、一个产品都可以认为是实体。相同类型的实体可以构成一个实体集。例如，全体学生就是一个实体集。在E-R图中实体一般用矩形表示，矩形框内写明实体的名称。例如，写一个老师的实体，如图所示。1.2.属性（Attribute）属性是实体所具有的某一特性，一个实体可由若干个属性来刻画。在E-R图中一般用椭圆形表示，并用无向边将其与相应的实体连接起来。例如，产品的名称、价格、类型等都是属性。例如，给老师实体加上属性：姓名、年龄、所教专业、所属院系，如图所示。1.3.联系（Relationship）联系，即在信息世界中反映实体内部或实体之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系。在E-R图中用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型。实体之间存在着3种联系类型，分别是一对一、一对多、多对多，它们反映到E-R图中即为相应的联系类型，即1:1、1:n和m:n。一对一关系（1:1）一对一关系是指实体集A与实体集B，A中的每一个实体至多与B实体集中一个实体有联系；反之，在实体集B中的每个实体至多与实体集A中一个实体有联系。例如，给学生排座，学生实体和座位实体之间的关系，每一个学生最多可以分得一个座位，同时每一个座位最多只能有一个学生来坐。用图形表示如图所示。一对多关系（1:n）一对多关系是指实体集A与实体集B中至少有n（n&gt;0）个实体有联系，并且实体集B中每一个实体至多与实体集A中一个实体有联系。例如，学生实体和班级实体之间的关系，一个班级里面可以有若干个学生，而每一个学生都属于这个班级。用图形表示如图所示。多对多关系（m:n）多对多关系是指实体集A中的每一个实体与实体集B中至少m（m&gt;0）个实体有联系，并且实体集B中的每一个实体与实体集A中的至少n（n&gt;0）个实体有联系。例如，顾客在商场购买商品，顾客与商品之间就是多对多的关系，每一个顾客都可以购买多种商品，而每一种商品又可以被多个顾客购买。用图形表示如图所示。其实，实体之间的这3种关系，不仅对两个实体有效，也可以表示多个实体之间的关系。2.E-R图绘制实例绘制一个网上购物系统的E-R图，在网上购物系统中简单分析出顾客、商品、商品类型、订单4个实体。下面分别绘制每个实体属性图并在最后绘制一个整体的E-R图。顾客实体属性图顾客实体主要包括用户编号、姓名、年龄、性别、身份证号、联系方式、送货地址、银行卡卡号8个属性，实体属性图如图所示。商品实体属性图商品实体主要包括商品编号、商品名称、商品价格、商品数量、商品描述5个属性，实体属性图如图所示。商品类型实体属性图商品类型实体主要包括商品类型编号和商品类型两个属性，实体属性图如图所示。订单实体属性图订单实体主要包括订单编号、送货地址、顾客姓名、是否付款、联系方式、所购商品6个属性，实体属性图如图所示。网上购物系统E-R图在绘制整体的E-R图之前，先要了解一下网上购物系统的购物流程。首先由顾客选择要购买的商品，之后把购买商品的列表生成一个订单，然后网站的售后人员会根据订单的地址送货，在这个网上购物系统里要求一个顾客每次只能生成一个订单。那么，这4个实体之间是什么关系呢？首先商品和顾客之间的关系是多对多的关系，多个商品可以被一个顾客购买，同时多个顾客也可以购买相同的商品；订单和商品之间的关系是一对多的关系，一个订单是由多个商品组成的，多个商品组成一个订单；顾客和订单之间的关系是一对一的关系，一个顾客可以生成一个订单，一个订单只能属于一个顾客；商品和商品类型之间的关系是一对一的关系，一个商品属于一种商品类型。网上购物系统的E-R图如图所示。"}, "md/概念/Oracle数据类型.html": {"url": "md/概念/Oracle数据类型.html", "title": "Oracle 数据类型", "keywords": "", "body": "Oracle数据类型要使用数据库来存储数据，首先就要知道这个数据库都能存储什么类型的数据。数据类型是在向数据表中存储数据前必须设定好的，就像如果要使用记事本查看文件内容，那么文件就要是文本的，不能有图片，否则图片是查看不了的，因为记事本中只能查看文本文件。官网文档-->在Oracle11g中提供的数据类型有23种，下面介绍常用的数据类型，并把数据类型分为字符型、数字型、日期类型和其他数据类型4类进行讲解。1.字符型字符型在Oracle11g中有VARCHAR2、char、nchar、nvarchar2和long五种，它们在数据库中是以ASCII码的格式存储的。下面用一个表格来讲解每种数据类型的作用。数据类型取值范围（字节）说明VARCHAR20~4000可变长度的字符串nvarchar20~1000用来存储Unicode字符集的变长字符串型数据CHAR0~2000用于描述定长的字符型数据nchar0~1000用来存储Unicode字符集的定长字符型数据long0~2GB用来存储变长的字符串2.数字型数字型在Oracle11g中常用的有NUMBER和float类型两种，可以用它们来表示整数和小数。数据类型取值范围说明NUMBER(p,s)p最大精度是38位（十进制）p代表的是精度，s代表的是保留的小数位数；可以用来存储定长整数和小数float用来存储126位数据（二进制）存储的精度是按二进制计算的。精度范围为二进制的1~126。在转化为十进制时需要乘以0.301033.日期类型日期类型在Oracle11g中常用的有DATE和timestamp两种类型，可以用它们来存放日期和时间。数据类型说明DATE用来存储日期和时间，范围在公元前4712年1月1日到公园9999年12月31日timestamp用来存储日期和时间，与DATE类型的区别就是在显示日期和时间更精确，DATE类型的时间精确到秒，而timestamp的数据类型可以精确到小数秒。此外，使用timestamp存放日期和时间还能够显示当前时上午还是下午4.其他数据类型除了上面讲过的字符型、数字型、日期类型之外，在Oracle11g中还有存放大数据的数据类型以及存放二进制文件的数据类型。数据类型取值范围（字节）说明blob最多可以存放4GB存储二进制数据clob最多可以存放4GB存储字符串数据bfile大小与操作系统有关用来把非结构化的二进制数据存储在数据库以外的操作系统中"}, "md/exercise/index.html": {"url": "md/exercise/index.html", "title": "Oracle 练习汇总", "keywords": "", "body": "Oracle练习汇总1.表结构介绍奖金表：bonus序号列名类型说明1enameVARCHAR2(50)姓名2jobVARCHAR2(20)职位3salNUMBER薪水4commNUMBER奖金（佣金）部门表：dept序号列名类型说明1DEPTNONUMBER(2)部门编号，主键2DNAMEVARCHAR2(14)部门名称3LOCVARCHAR2(13)部门位置雇员表：emp序号列名类型说明1EMPNONUMBER(4)员工编号，EMP表主键2ENAMEVARCHAR2(50)员工姓名3JOBVARCHAR2(9)员工工作4MGRNUMBER(4)员工的领导编号，引用EMPNO5HIREDATEDATE入职日期6SALNUMBER(7,2)员工工资7COMMNUMBER(7,2)员工奖金8DEPTNONUMBER(2)员工部门编号，是表DEPT的外键。薪水等级表：salgrade序号列名类型说明1GRADENUMBER等级2LOSALNUMBER此等级下最低工资3HISALNUMBER此等级下最高工资学生表：STUDENT序号列名类型说明1IDNUMBER学生的编号2NAMEVARCHAR2(50)名字成绩表：ACHIEVEMENT序号列名类型说明1IDNUMBER学生的编号2NAMENUMBER成绩成绩表：userorgz序号列名类型说明1IDNUMBER编号2USERNAMEVARCHAR2(50)用户名3MOBILEPHONENUMBER手机号码2.创建数据SQLCreateData.sql"}, "md/exercise/001.html": {"url": "md/exercise/001.html", "title": "Oracle 练习 001", "keywords": "", "body": "Oracle练习0011.题目新建一个用户tom，密码设置为love2.实例点我看答案CREATEUSERtomIDENTIFIEDBYloveACCOUNTUNLOCK;"}, "md/exercise/002.html": {"url": "md/exercise/002.html", "title": "Oracle 练习 002", "keywords": "", "body": "Oracle练习0021.题目给用户tom授权登录，访问资源的权限2.实例点我看答案GRANTCONNECT,RESOURCETOtom;"}, "md/exercise/003.html": {"url": "md/exercise/003.html", "title": "Oracle 练习 003", "keywords": "", "body": "Oracle练习0031.题目锁定tom用户的账户，使其不能登录2.实例点我看答案ALTERUSERtomACCOUNTLOCK;"}, "md/exercise/004.html": {"url": "md/exercise/004.html", "title": "Oracle 练习 004", "keywords": "", "body": "Oracle练习0041.题目给tom用户解锁2.实例点我看答案ALTERUSERtomACCOUNTUNLOCK;"}, "md/exercise/005.html": {"url": "md/exercise/005.html", "title": "Oracle 练习 005", "keywords": "", "body": "Oracle练习0051.题目收回tom用户的登录、访问资源的权限2.实例点我看答案REVOKECONNECT,RESOURCEFROMtom;"}, "md/exercise/006.html": {"url": "md/exercise/006.html", "title": "Oracle 练习 006", "keywords": "", "body": "Oracle练习0061.题目删除用户tom2.实例点我看答案DROPUSERtom;"}, "md/exercise/007.html": {"url": "md/exercise/007.html", "title": "Oracle 练习 007", "keywords": "", "body": "Oracle练习0071.题目创建表class_info字段名类型长度可选值c_id字符串20主键c_type字符串6UI、测试、开发c_position字符串20非空start_time日期c_status字符串6在读、毕业2.实例点我看答案CREATETABLEclass_info(c_idVARCHAR2(20)PRIMARYKEY,c_typeVARCHAR2(10)CHECK(c_typein(&#x27;UI&#x27;,&#x27;测试&#x27;,&#x27;开发&#x27;)),c_positionVARCHAR2(20)NOTNULL,start_timeDATE,c_statusVARCHAR2(10)CHECK(c_statusin(&#x27;在读&#x27;,&#x27;毕业&#x27;)));"}, "md/exercise/008.html": {"url": "md/exercise/008.html", "title": "Oracle 练习 008", "keywords": "", "body": "Oracle练习0081.题目把表class_info改成class_info22.实例点我看答案renameclass_infotoclass_info2;"}, "md/exercise/009.html": {"url": "md/exercise/009.html", "title": "Oracle 练习 009", "keywords": "", "body": "Oracle练习0091.题目显示薪水大于2000，且工作类别是经理的雇员信息2.实例点我看答案select*fromempewheree.sal&gt;2000ande.job=&#x27;经理&#x27;;"}, "md/exercise/010.html": {"url": "md/exercise/010.html", "title": "Oracle 练习 010", "keywords": "", "body": "Oracle练习0101.题目显示年薪大于30000，工作类别不是经理的雇员信息2.实例点我看答案select*fromempewheree.sal*12&gt;30000ande.job!=&#x27;经理&#x27;;"}, "md/exercise/011.html": {"url": "md/exercise/011.html", "title": "Oracle 练习 011", "keywords": "", "body": "Oracle练习0111.题目显示薪水在1500到3000之间，工作类别以M开头的雇员信息2.实例点我看答案select*fromempewheree.salbetween1500and3000ande.joblike&#x27;M%&#x27;;"}, "md/exercise/012.html": {"url": "md/exercise/012.html", "title": "Oracle 练习 012", "keywords": "", "body": "Oracle练习0121.题目显示佣金为空并且部门号为20或30的雇员信息2.实例点我看答案select*fromempewheree.commisnulland(e.deptno=20ore.deptno=30);select*fromempewheree.commisnullande.deptnoin(20,30);"}, "md/exercise/013.html": {"url": "md/exercise/013.html", "title": "Oracle 练习 013", "keywords": "", "body": "Oracle练习0131.题目显示佣金不为空或者部门号为20的雇员信息，要求按照薪水降序排列2.实例点我看答案select*fromempewheree.commisnotnullore.deptno=20orderbye.saldesc;"}, "md/exercise/014.html": {"url": "md/exercise/014.html", "title": "Oracle 练习 014", "keywords": "", "body": "Oracle练习0141.题目显示年薪大于30000工作类别不是经理，且部门号不是10和40的雇员信息，要求按照雇员姓名进行排序2.实例点我看答案select*fromempewheree.sal*12&gt;30000ande.job!=&#x27;经理&#x27;ande.deptnonotin(10,40)orderbye.ename;"}, "md/exercise/015.html": {"url": "md/exercise/015.html", "title": "Oracle 练习 015", "keywords": "", "body": "Oracle练习0151.题目选择在部门30中员工的所有信息2.实例点我看答案select*fromempewheree.deptno=30;"}, "md/exercise/016.html": {"url": "md/exercise/016.html", "title": "Oracle 练习 016", "keywords": "", "body": "Oracle练习0161.题目列出职位为经理的员工的编号，姓名2.实例点我看答案selecte.empno,e.enamefromempewheree.job=&#x27;经理&#x27;;"}, "md/exercise/017.html": {"url": "md/exercise/017.html", "title": "Oracle 练习 017", "keywords": "", "body": "Oracle练习0171.题目找出部门10中的经理和部门20中的普通员工2.实例点我看答案select*fromempewhere(e.deptno=10ande.job=&#x27;经理&#x27;)or(e.deptno=20ande.job=&#x27;普通员工&#x27;);"}, "md/exercise/018.html": {"url": "md/exercise/018.html", "title": "Oracle 练习 018", "keywords": "", "body": "Oracle练习0181.题目找出部门10中既不是经理也不是普通员工，而且工资大于等于2000的员工2.实例点我看答案select*fromempewheree.deptno=10ande.jobnotin(&#x27;经理&#x27;,&#x27;普通员工&#x27;)ande.sal&gt;=2000;"}, "md/exercise/019.html": {"url": "md/exercise/019.html", "title": "Oracle 练习 019", "keywords": "", "body": "Oracle练习0191.题目找出没有奖金或者奖金低于500的员工2.实例点我看答案select*fromempewheree.commisnullore.comm&lt;500;"}, "md/exercise/020.html": {"url": "md/exercise/020.html", "title": "Oracle 练习 020", "keywords": "", "body": "Oracle练习0201.题目显示雇员姓名，根据其服务年限，将最老的雇员排在最前面2.实例点我看答案selecte.enamefromempeorderbye.hiredateasc;"}, "md/exercise/021.html": {"url": "md/exercise/021.html", "title": "Oracle 练习 021", "keywords": "", "body": "Oracle练习0211.题目找出有奖金的员工的不同工作2.实例点我看答案selectdistincte.jobfromempewheree.commisnotnull;"}, "md/exercise/022.html": {"url": "md/exercise/022.html", "title": "Oracle 练习 022", "keywords": "", "body": "Oracle练习0221.题目找出姓名中不带R这个字母的员工2.实例点我看答案select*fromempewheree.enamenotlike&#x27;%R%&#x27;;"}, "md/exercise/023.html": {"url": "md/exercise/023.html", "title": "Oracle 练习 023", "keywords": "", "body": "Oracle练习0231.题目显示所有员工，按工作降序排列，若相同，则按工资升序排序2.实例点我看答案select*fromempeorderbye.jobdesc,e.salasc;"}, "md/exercise/024.html": {"url": "md/exercise/024.html", "title": "Oracle 练习 024", "keywords": "", "body": "Oracle练习0241.题目查找出不属于任何部门的员工2.实例点我看答案select*fromempewheree.deptnoisnull;"}, "md/exercise/025.html": {"url": "md/exercise/025.html", "title": "Oracle 练习 025", "keywords": "", "body": "Oracle练习0251.题目创建一查询，显示与BLAKE在同一部门工作的雇员的姓名和受雇日期、部门编号，但是BLAKE不包含在内。2.实例点我看答案selecte.ename,e.hiredate,e.deptnofromempejoinempe1one.deptno=e1.deptnoande1.ename=&#x27;BLAKE&#x27;wheree.ename!=&#x27;BLAKE&#x27;;"}, "md/exercise/026.html": {"url": "md/exercise/026.html", "title": "Oracle 练习 026", "keywords": "", "body": "Oracle练习0261.题目显示位置在达拉斯的部门内的雇员姓名、工作。2.实例点我看答案selecte.ename,e.jobfromempejoindeptdone.deptno=d.deptnoandd.loc=&#x27;达拉斯&#x27;;"}, "md/exercise/027.html": {"url": "md/exercise/027.html", "title": "Oracle 练习 027", "keywords": "", "body": "Oracle练习0271.题目显示被KING直接管理的雇员的姓名以及薪水。2.实例点我看答案selecte.ename,e.salfromempejoinempe1one.mgr=e1.empnoande1.ename=&#x27;KING&#x27;;"}, "md/exercise/028.html": {"url": "md/exercise/028.html", "title": "Oracle 练习 028", "keywords": "", "body": "Oracle练习0281.题目创建一查询，显示能获得与SCOTT一样薪水的其他雇员的姓名、受雇日期以及薪水。2.实例点我看答案selecte.ename,e.hiredate,e.salfromempejoinempe1one.sal=e1.salande1.ename=&#x27;SCOTT&#x27;wheree.ename!=&#x27;SCOTT&#x27;;"}, "md/exercise/029.html": {"url": "md/exercise/029.html", "title": "Oracle 练习 029", "keywords": "", "body": "Oracle练习0291.题目查找出工资等级不为4级的员工的员工名字，部门名字，部门位置。2.实例点我看答案selecte.ename,d.dname,d.loc,s.gradefromempejoinsalgradesone.salbetweens.losalands.hisalands.grade!=4leftjoindeptdone.deptno=d.deptno;"}, "md/exercise/030.html": {"url": "md/exercise/030.html", "title": "Oracle 练习 030", "keywords": "", "body": "Oracle练习0301.题目找出每个月倒数第三天受雇的员工（如：2009-5-29）2.实例点我看答案select*fromempewheree.hiredate=last_day(e.hiredate)-2;"}, "md/exercise/031.html": {"url": "md/exercise/031.html", "title": "Oracle 练习 031", "keywords": "", "body": "Oracle练习0311.题目找出25年前雇的员工2.实例点我看答案select*fromempewhere(sysdate-e.hiredate)/12/30&gt;25;select*fromempewheremonths_between(sysdate,e.hiredate)/12&gt;25;select*fromempewhereadd_months(sysdate,-25*12)&gt;=e.hiredate;"}, "md/exercise/032.html": {"url": "md/exercise/032.html", "title": "Oracle 练习 032", "keywords": "", "body": "Oracle练习0321.题目所有员工名字前加上Dear,并且名字首字母大写2.实例点我看答案selecte.ename,&#x27;Dear&#x27;||initcap(e.ename)fromempe;selecte.ename,concat(&#x27;Dear&#x27;,initcap(e.ename))fromempe;"}, "md/exercise/033.html": {"url": "md/exercise/033.html", "title": "Oracle 练习 033", "keywords": "", "body": "Oracle练习0331.题目找出姓名为5个字符的员工2.实例点我看答案select*fromempewherelength(e.ename)=5;"}, "md/exercise/034.html": {"url": "md/exercise/034.html", "title": "Oracle 练习 034", "keywords": "", "body": "Oracle练习0341.题目显示所有员工的姓名的第一个字2.实例点我看答案selecte.ename,substr(e.ename,1,1)fromempe;"}, "md/exercise/035.html": {"url": "md/exercise/035.html", "title": "Oracle 练习 035", "keywords": "", "body": "Oracle练习0351.题目找到2月份受雇的员工2.实例点我看答案select*fromempewhereto_char(e.hiredate,&#x27;mm&#x27;)=2;"}, "md/exercise/036.html": {"url": "md/exercise/036.html", "title": "Oracle 练习 036", "keywords": "", "body": "Oracle练习0361.题目对薪水是2000元以下的员工进行查询，如果没有发奖金，每人奖金100元。2.实例点我看答案selectename,job,sal,nvl(comm,100)fromempwheresal&lt;2000;"}, "md/exercise/037.html": {"url": "md/exercise/037.html", "title": "Oracle 练习 037", "keywords": "", "body": "Oracle练习0371.题目对EMP表中薪水为2000元以下的员工进行查询，如果没有奖金，则显示奖金为200元，如果有奖金，则在原来的奖金基础上加100元。2.实例点我看答案selectename,job,sal,nvl2(comm,comm+100,200)&quot;comm&quot;fromempwheresal&lt;2000;"}, "md/exercise/038.html": {"url": "md/exercise/038.html", "title": "Oracle 练习 038", "keywords": "", "body": "Oracle练习0381.题目列出至少有一个员工的所有部门2.实例点我看答案select*fromdeptdwhered.deptnoin(selecte.deptnofromempegroupbye.deptnohavingcount(e.ename)&gt;0);"}, "md/exercise/039.html": {"url": "md/exercise/039.html", "title": "Oracle 练习 039", "keywords": "", "body": "Oracle练习0391.题目查询出KING所在部门的工作年限最大的员工名字2.实例点我看答案selecte.ename,e.hiredate,e.deptnofromempewheree.hiredate=(selectmin(hiredate)fromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;))ande.deptno=(selectdeptnofromempwhereename=&#x27;KING&#x27;);"}, "md/exercise/040.html": {"url": "md/exercise/040.html", "title": "Oracle 练习 040", "keywords": "", "body": "Oracle练习0401.题目查询出KING所在部门的部门号、部门名称、部门人数2.实例点我看答案selectd.deptno,d.dname,t.人数fromdeptd,(selectcount(*)人数,deptnofromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;)groupbydeptno)twhered.deptno=t.deptno;selectd.dname,d.deptno,t2.*fromdeptd,(selectt.人数,t.deptnofrom(selectcount(*)人数,deptnofromempgroupbydeptno)twheret.deptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;))t2whered.deptno=t2.deptno;selecte.deptno部门号,d.dname部门名称,(selectcount(*)from(selectdeptnofromempwheredeptnoin(selectdeptnofromempwhereename=&#x27;KING&#x27;)))人数fromempe,deptdwheree.deptno=d.deptnoande.ename=&#x27;KING&#x27;;"}, "md/exercise/041.html": {"url": "md/exercise/041.html", "title": "Oracle 练习 041", "keywords": "", "body": "Oracle练习0411.题目算出部门30中得到最多奖金的员工姓名2.实例点我看答案selectename,comm,deptnofromempwherecomm=(selectmax(comm)fromempwheredeptno=30)anddeptno=30;"}, "md/exercise/042.html": {"url": "md/exercise/042.html", "title": "Oracle 练习 042", "keywords": "", "body": "Oracle练习0421.题目统计各部门下平均工资大于500的部门2.实例点我看答案selectdeptno,avg(sal)fromempgroupbydeptnohavingavg(sal)&gt;500;"}, "md/exercise/043.html": {"url": "md/exercise/043.html", "title": "Oracle 练习 043", "keywords": "", "body": "Oracle练习0431.题目按部门统计员工数，查出员工数最多的部门的第二名到第五名（列出部门名字，部门位置）2.实例点我看答案selectd.dname,d.loc,d.deptnofromdeptd,(selectrownumno,deptnofrom(selectcount(*)人数,deptnofromempgroupbydeptnoorderby人数desc))ewheree.nobetween2and5ande.deptno=d.deptno;"}, "md/exercise/044.html": {"url": "md/exercise/044.html", "title": "Oracle 练习 044", "keywords": "", "body": "Oracle练习0441.题目查找出部门10和部门20中，工资最高第3名到第5名的员工的员工名字，部门名字，部门位置2.实例点我看答案selectd.dname,d.loc,e.enamefromdeptd,(selectename,sal,deptno,rownumnofrom(select*fromempwheredeptnoin(10,20)orderbysaldesc))ewhered.deptno=e.deptnoande.nobetween3and5;"}, "md/exercise/045.html": {"url": "md/exercise/045.html", "title": "Oracle 练习 045", "keywords": "", "body": "Oracle练习0451.题目从EMP表中查询如果其工资大于3500，则显示高工资。工资大于2000小于等于3500，则显示中等工资。工资小于等于2000的则显示低等工资。2.实例点我看答案selecte.ename,e.sal,(casewhene.sal&gt;3500then&#x27;高工资&#x27;whene.sal&gt;2000then&#x27;中等工资&#x27;else&#x27;低等工资&#x27;end)工资等级fromempe;"}, "md/exercise/046.html": {"url": "md/exercise/046.html", "title": "Oracle 练习 046", "keywords": "", "body": "Oracle练习0461.题目已知有如下数据表：A月份部门业绩一月份A10一月份B10一月份C5二月份A8二月份B9三月份A8写出相应SQL，得到以下结果集：部门一月份二月份三月份A1088B1090C5002.实例点我看答案select部门,max(case月份when&#x27;一月份&#x27;then业绩else0end)一月份,max(case月份when&#x27;二月份&#x27;then业绩else0end)二月份,max(case月份when&#x27;三月份&#x27;then业绩else0end)三月份fromAgroupby部门;"}, "md/exercise/047.html": {"url": "md/exercise/047.html", "title": "Oracle 练习 047", "keywords": "", "body": "Oracle练习0471.题目从EMP表中查询统计各部门工资低于（包含）2000的人数与高于2000的人数2.实例点我看答案selecte.deptno,count(casewhene.sal&lt;=2000thene.salelsenullend)&quot;&lt;=2000&quot;,count(casewhene.sal&gt;2000thene.salelsenullend)&quot;&gt;2000&quot;fromempegroupbye.deptno;"}, "md/exercise/048.html": {"url": "md/exercise/048.html", "title": "Oracle 练习 048", "keywords": "", "body": "Oracle练习0481.题目从Student表和Achievement表中查询成绩&gt;85分的学生的姓名2.实例点我看答案selects.id,s.name,a.markfromstudents,achievementawheres.id=a.idanda.mark&gt;85;"}, "md/exercise/049.html": {"url": "md/exercise/049.html", "title": "Oracle 练习 049", "keywords": "", "body": "Oracle练习0491.题目从Student表和Achievement表中查询成绩&gt;=90分的人数2.实例点我看答案selectcount(*)fromachievementawherea.mark&gt;=90;"}, "md/exercise/050.html": {"url": "md/exercise/050.html", "title": "Oracle 练习 050", "keywords": "", "body": "Oracle练习0501.题目操作Student表和Achievement表Robert此次考试考了80分，但是成绩没能录入表中，请将其成绩添加进去2.实例点我看答案insertintoachievement(id,mark)values((selectidfromstudentwherename=&#x27;Robert&#x27;),80);"}, "md/exercise/051.html": {"url": "md/exercise/051.html", "title": "Oracle 练习 051", "keywords": "", "body": "Oracle练习0511.题目操作Student表和Achievement表将Rose的成绩修改为872.实例点我看答案updateachievementaseta.mark=87wherea.id=(selects.idfromstudentswherename=&#x27;Rose&#x27;);"}, "md/exercise/052.html": {"url": "md/exercise/052.html", "title": "Oracle 练习 052", "keywords": "", "body": "Oracle练习0521.题目操作Student表和Achievement表删除Betty的记录2.实例点我看答案deletefromachievementwhereid=(selectidfromstudentwherename=&#x27;Betty&#x27;);deletefromstudentwherename=&#x27;Betty&#x27;;"}, "md/exercise/053.html": {"url": "md/exercise/053.html", "title": "Oracle 练习 053", "keywords": "", "body": "Oracle练习0531.题目查询userorgz表，统计出有手机号码重复的手机号码以及重复个数，并根据重复数量降序排序且手机重复个数必须大于12.实例点我看答案selectmobilephone,count(*)fromuserorgzgroupbymobilephonehavingcount(*)&gt;1orderbycount(*)desc;"}, "md/exercise/选择题.html": {"url": "md/exercise/选择题.html", "title": "Oracle 选择题", "keywords": "", "body": "Oracle选择题1.题目SQL指的是？A.StrongQuestionLanguageB.StructuredQuestionLanguageC.StructuredQueryLanguage哪个SQL语句用于从数据库中提取数据？A.SELECTB.OPENC.GETD.EXTRACT哪条SQL语句用于更新数据库中的数据？A.UPDATEB.SAVEC.SAVEASD.MODIFY哪条SQL语句用于删除数据库中的数据？A.REMOVEB.DELETEC.COLLAPSE哪条SQL语句用于在数据库中插入新数据？A.ADDNEWB.INSERTNEWC.INSERTINTOD.ADDRECORD使用SQL，如何从名为Persons的表中选择名为FirstName的列？A.EXTRACTFirstNameFROMPersonsB.SELECTFirstNameFROMPersonsC.SELECTPersons.FirstName使用SQL，如何从名为Persons的表中选择所有列？A.SELECTPersonsB.SELECT*.PersonsC.SELECT[all]FROMPersonsD.SELECT*FROMPersons使用SQL，如何从名为Persons的表中选择FirstName列的值为Peter的所有记录？A.SELECT[all]FROMPersonsWHEREFirstName='Peter'B.SELECT[all]FROMPersonsWHEREFirstNameLIKE'Peter'C.SELECT*FROMPersonsWHEREFirstName='Peter'D.SELECT*FROMPersonsWHEREFirstName&lt;&gt;'Peter'使用SQL，如何从名为Persons的表中选择所有记录，其中FirstName列的值以a开头？A.SELECT*FROMPersonsWHEREFirstNameLIKE'％a'B.SELECT*FROMPersonsWHEREFirstName='％a％'C.SELECT*FROMPersonsWHEREFirstName='a'D.SELECT*FROMPersonsWHEREFirstNameLIKE'a％'如果列出的任何条件为真，OR运算符将显示一条记录。如果列出的所有条件都为真，AND运算符将显示一条记录A.TrueB.False使用SQL，如何在表Persons中选择FirstName等于Peter而LastName等于Jackson的所有记录？A.SELECTFirstName='Peter',LastName='Jackson'FROMPersonsB.SELECT*FROMPersonsWHEREFirstName='Peter'ANDLast-Name='Jackson'C.SELECT*FROMPersonsWHEREFirstName&lt;&gt;'Peter'ANDLast-Name&lt;&gt;'Jackson'使用SQL，如何按字母顺序选取Persons表中LastName介于（包含）Hansen和Pettersen的所有记录？A.SELECTLastName&gt;'Hansen'ANDLastName&lt;'Pettersen'FROMPersonsB.SELECT*FROMPersonsWHERELastNameBETWEEN'Hansen'AND'Pet-tersen'C.SELECT*FROMPersonsWHERELastName&gt;'Hansen'ANDLast-Name&lt;'Pettersen'哪条SQL语句可返回唯一不同的值？A.SELECTDISTINCTB.SELECTDIFFERENT哪个SQL关键词用于对结果集进行排序？A.SORTB.ORDERC.ORDERBYD.SORTBY使用SQL，如何根据&quot;FirstName&quot;列降序地从&quot;Persons&quot;表返回所有记录？A.SELECT*FROMPersonsSORTBY'FirstName'DESCB.SELECT*FROMPersonsSORT'FirstName'DESCC.SELECT*FROMPersonsORDERFirstNameDESCD.SELECT*FROMPersonsORDERBYFirstNameDESC使用SQL，如何向&quot;Persons&quot;表插入新的记录？A.INSERT('Jimmy','Jackson')INTOPersonsB.INSERTVALUES('Jimmy','Jackson')INTOPersonsC.INSERTINTOPersonsVALUES('Jimmy','Jackson')使用SQL，如何向&quot;Persons&quot;表中的&quot;LastName&quot;列插入&quot;Olsen&quot;？A.INSERTINTOPersons(LastName)VALUES('Olsen')B.INSERT('Olsen')INTOPersons(LastName)C.INSERTINTOPersons('Olsen')INTOLastName使用SQL，如何把&quot;Persons&quot;表中&quot;LastName&quot;列的&quot;Hansen&quot;改为&quot;Nilsen&quot;？A.UPDATEPersonsSETLastName='Hansen'INTOLastName='Nilsen'B.MODIFYPersonsSETLastName='Hansen'INTOLastName='NilsenC.UPDATEPersonsSETLastName='Nilsen'WHERELastName='Hansen'D.MODIFYPersonsSETLastName='Nilsen'WHERELastName='Hansen'使用SQL，如何在&quot;Persons&quot;表中删除&quot;FirstName&quot;等于&quot;Peter&quot;的纪录？A.DELETEFirstName='Peter'FROMPersonsB.DELETEROWFirstName='Peter'FROMPersonsC.DELETEFROMPersonsWHEREFirstName='Peter'使用SQL，如何返回&quot;Persons&quot;表中记录的数目？A.SELECTNO(*)FROMPersonsB.SELECTCOUNT(*)FROMPersonsC.SELECTLEN(*)FROMPersonsD.SELECTCOLUMNS(*)FROMPersons哪个操作符用于选择范围内的值？A.BETWEENB.RANGEC.WITHINNOTNULL约束强制约束列不接受空值。A.FalseB.True哪个操作符用于在列中模糊搜索？A.GETB.LIKEC.FROM哪个SQL语句用于在数据库中创建表？A.CREATEDATABASETABLEB.CREATEDBC.CREATEDATABASETABD.CREATETABLE2.答案点我看答案12345678910CAABCBDCDA11121314151617181920BBACDCACCB21222324ABBD"}}